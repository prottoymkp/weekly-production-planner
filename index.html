<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weekly Production Planner</title>
  <style>
    /* Basic styling for the planner */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      border: 1px solid #ccc;
      padding: 4px;
      text-align: left;
    }

    th {
      background-color: #f2f2f2;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    tfoot td {
      font-weight: bold;
    }

    button {
      margin-right: 5px;
    }

    .month-picker-input {
      width: 140px;
      cursor: pointer;
      background-color: #fff;
    }

    .month-calendar {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.12);
      padding: 8px;
      border-radius: 4px;
      width: 240px;
      z-index: 10;
    }

    .month-calendar.hidden {
      display: none;
    }

    .month-calendar header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }

    .month-calendar .year-label {
      font-weight: bold;
      flex: 1;
      text-align: center;
    }

    .month-calendar button {
      margin: 0;
    }

    .month-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .month-grid button {
      padding: 8px 6px;
      background: #f7f7f7;
      border: 1px solid #ddd;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }

    .month-grid button:hover,
    .month-grid button:focus {
      outline: none;
      background: #e7f0ff;
      border-color: #b3d1ff;
    }

    .month-grid .current-month {
      background: #007bff;
      color: #fff;
      border-color: #007bff;
    }

    .numeric-input {
      width: 80px;
    }

    .date-input {
      width: 150px;
    }

    /* Plan chart styling */
    #chartContainer {
      width: min(1100px, calc(100% - 24px));
      margin: 16px auto 0;
      display: flex;
      gap: 12px;
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      background: #fff;
      border: 1px solid #ddd;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      padding: 8px;
      box-sizing: border-box;
    }

    .chart-panel {
      flex: 0 0 340px;
      padding: 6px;
      border: 1px solid #eee;
      border-radius: 4px;
      background: #fafafa;
    }

    .chart-panel h3 {
      margin: 4px 0 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .chart-panel canvas {
      width: 100%;
      height: 200px;
      max-width: 340px;
      display: block;
      margin: 0 auto;
    }
  </style>
  <!-- SheetJS library for XLSX export -->
  <!-- The 0.18.7 release is not available on the CDN which caused the
       "XLSX library not loaded" alert.  Falling back to the latest version
       provided by the CDN fixes the issue. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
  <body>
  <div id="toolbar">
    <label for="monthPicker">Month: </label>
    <input
      id="monthPicker"
      type="text"
      class="month-picker-input"
      aria-label="Filter charts by month"
      placeholder="YYYY-MM"
      readonly
    />
    <button id="addRowBtn">Add Row</button>
    <button id="add10RowsBtn">Add 10 Rows</button>
    <button id="sampleDataBtn" type="button">Sample Data</button>
    <button id="runTestsBtn" type="button">Run tests</button>
    <button id="exportBtn" type="button">Export XLSX (Table Only)</button>
  </div>

  <table id="plannerTable">
    <thead>
      <tr>
        <th>Week</th>
        <th>Date</th>
        <th>Article</th>
        <th>Order Quantity</th>
        <th>Cutting Plan</th>
        <th>Cutting Actual</th>
        <th>Cutting %</th>
        <th>Stitching Plan</th>
        <th>Stitching Actual</th>
        <th>Stitching %</th>
        <th>Lasting Plan</th>
        <th>Lasting Actual</th>
        <th>Lasting %</th>
        <th>Working Days (week)</th>
        <th>Remarks</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <!-- Dynamic rows will be appended here -->
    </tbody>
    <tfoot>
      <tr>
        <td colspan="4">Grand Total</td>
        <td class="total-cut-plan">0</td>
        <td class="total-cut-actual">0</td>
        <td></td>
        <td class="total-stitch-plan">0</td>
        <td class="total-stitch-actual">0</td>
        <td></td>
        <td class="total-last-plan">0</td>
        <td class="total-last-actual">0</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
    </tfoot>
  </table>

  <div id="chartContainer" aria-label="Production plan charts">
    <div class="chart-panel" aria-label="Cutting performance chart">
      <h3>Cutting</h3>
      <canvas id="cutChart" width="340" height="200"></canvas>
    </div>
    <div class="chart-panel" aria-label="Sewing performance chart">
      <h3>Sewing</h3>
      <canvas id="stitchChart" width="340" height="200"></canvas>
    </div>
    <div class="chart-panel" aria-label="Lasting performance chart">
      <h3>Lasting</h3>
      <canvas id="lastChart" width="340" height="200"></canvas>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    const tableBody = document.querySelector('#plannerTable tbody');
    const addRowBtn = document.getElementById('addRowBtn');
    const add10RowsBtn = document.getElementById('add10RowsBtn');
    const sampleDataBtn = document.getElementById('sampleDataBtn');
    const runTestsBtn = document.getElementById('runTestsBtn');
    const exportBtn = document.getElementById('exportBtn');
    const monthPicker = document.getElementById('monthPicker');
    let selectedMonth = '';
    let calendarYear = new Date().getFullYear();
    const chartConfigs = [
      { id: 'cutChart', planIndex: 4, actualIndex: 5, title: 'Plan vs Actual (Cutting)' },
      { id: 'stitchChart', planIndex: 7, actualIndex: 8, title: 'Plan vs Actual (Sewing)' },
      { id: 'lastChart', planIndex: 10, actualIndex: 11, title: 'Plan vs Actual (Lasting)' }
    ];
    const chartContexts = chartConfigs.map(cfg => {
      const canvas = document.getElementById(cfg.id);
      return { canvas, ctx: canvas ? canvas.getContext('2d') : null, cfg };
    });

    const monthCalendar = buildMonthCalendar();
    document.body.appendChild(monthCalendar.container);

    function buildMonthCalendar() {
      const container = document.createElement('div');
      container.className = 'month-calendar hidden';
      container.setAttribute('role', 'dialog');
      container.setAttribute('aria-label', 'Choose a month');

      const header = document.createElement('header');
      const prevBtn = document.createElement('button');
      prevBtn.type = 'button';
      prevBtn.textContent = '◀';
      prevBtn.addEventListener('click', () => {
        renderMonthCalendar(calendarYear - 1);
      });

      const yearLabel = document.createElement('div');
      yearLabel.className = 'year-label';
      yearLabel.textContent = calendarYear;

      const nextBtn = document.createElement('button');
      nextBtn.type = 'button';
      nextBtn.textContent = '▶';
      nextBtn.addEventListener('click', () => {
        renderMonthCalendar(calendarYear + 1);
      });

      header.appendChild(prevBtn);
      header.appendChild(yearLabel);
      header.appendChild(nextBtn);
      container.appendChild(header);

      const grid = document.createElement('div');
      grid.className = 'month-grid';

      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const monthButtons = months.map((name, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = name;
        btn.addEventListener('click', () => {
          applySelectedMonth(formatMonthValue(calendarYear, idx));
          closeMonthCalendar();
        });
        grid.appendChild(btn);
        return btn;
      });

      container.appendChild(grid);

      return { container, yearLabel, monthButtons };
    }

    function formatMonthValue(year, monthIndex) {
      return `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
    }

    function applySelectedMonth(value, updateInput = true) {
      selectedMonth = value;
      if (updateInput) {
        monthPicker.value = value;
      }
      updateLineCharts();
    }

    function getParsedMonth(value) {
      if (!value || !/^\d{4}-\d{2}$/.test(value)) return null;
      const [yearStr, monthStr] = value.split('-');
      const year = parseInt(yearStr, 10);
      const monthIndex = parseInt(monthStr, 10) - 1;
      if (isNaN(year) || isNaN(monthIndex) || monthIndex < 0 || monthIndex > 11) return null;
      return { year, monthIndex };
    }

    function renderMonthCalendar(year) {
      calendarYear = year;
      monthCalendar.yearLabel.textContent = year;
      const parsed = getParsedMonth(selectedMonth);
      const activeMonth = parsed ? parsed.monthIndex : new Date().getMonth();
      monthCalendar.monthButtons.forEach((btn, idx) => {
        btn.classList.toggle('current-month', idx === activeMonth && year === (parsed ? parsed.year : new Date().getFullYear()));
      });
    }

    function openMonthCalendar() {
      const parsed = getParsedMonth(monthPicker.value) || { year: new Date().getFullYear(), monthIndex: new Date().getMonth() };
      renderMonthCalendar(parsed.year);
      const rect = monthPicker.getBoundingClientRect();
      monthCalendar.container.style.top = `${rect.bottom + window.scrollY + 4}px`;
      monthCalendar.container.style.left = `${rect.left + window.scrollX}px`;
      monthCalendar.container.classList.remove('hidden');
      monthCalendar.monthButtons[parsed.monthIndex].focus();
    }

    function closeMonthCalendar() {
      monthCalendar.container.classList.add('hidden');
    }

    /**
     * Add a new empty row to the table. All inputs are set up
     * with appropriate event handlers to trigger recalculation.
     */
    function addRow() {
      const tr = document.createElement('tr');
      // Week cell (read-only)
      const weekCell = document.createElement('td');
      weekCell.textContent = '';
      tr.appendChild(weekCell);

      // Date cell
      const dateCell = document.createElement('td');
      const dateInput = document.createElement('input');
      dateInput.type = 'date';
      dateInput.placeholder = 'yyyy-MM-dd';
      dateInput.className = 'date-input';
      dateInput.addEventListener('input', recalcAll);
      dateInput.addEventListener('blur', normalizeDateInput);
      dateInput.addEventListener('change', normalizeDateInput);
      dateCell.appendChild(dateInput);
      tr.appendChild(dateCell);

      // Article cell
      const articleCell = document.createElement('td');
      const articleInput = document.createElement('input');
      articleInput.type = 'text';
      articleInput.addEventListener('input', recalcAll);
      articleCell.appendChild(articleInput);
      tr.appendChild(articleCell);

      // Order Quantity cell (read-only, defaults to 0)
      const oqCell = document.createElement('td');
      oqCell.textContent = '0';
      tr.appendChild(oqCell);

      // Cutting Plan
      const cutPlanCell = document.createElement('td');
      const cutPlanInput = document.createElement('input');
      cutPlanInput.type = 'number';
      cutPlanInput.min = '0';
      cutPlanInput.step = '1';
      cutPlanInput.className = 'numeric-input';
      cutPlanInput.value = '0';
      cutPlanInput.addEventListener('input', recalcAll);
      cutPlanCell.appendChild(cutPlanInput);
      tr.appendChild(cutPlanCell);

      // Cutting Actual
      const cutActCell = document.createElement('td');
      const cutActInput = document.createElement('input');
      cutActInput.type = 'number';
      cutActInput.min = '0';
      cutActInput.step = '1';
      cutActInput.className = 'numeric-input';
      cutActInput.value = '0';
      cutActInput.addEventListener('input', recalcAll);
      cutActCell.appendChild(cutActInput);
      tr.appendChild(cutActCell);

      // Cutting % (read-only)
      const cutPctCell = document.createElement('td');
      cutPctCell.textContent = '0%';
      tr.appendChild(cutPctCell);

      // Stitching Plan
      const stitchPlanCell = document.createElement('td');
      const stitchPlanInput = document.createElement('input');
      stitchPlanInput.type = 'number';
      stitchPlanInput.min = '0';
      stitchPlanInput.step = '1';
      stitchPlanInput.className = 'numeric-input';
      stitchPlanInput.value = '0';
      stitchPlanInput.addEventListener('input', recalcAll);
      stitchPlanCell.appendChild(stitchPlanInput);
      tr.appendChild(stitchPlanCell);

      // Stitching Actual
      const stitchActCell = document.createElement('td');
      const stitchActInput = document.createElement('input');
      stitchActInput.type = 'number';
      stitchActInput.min = '0';
      stitchActInput.step = '1';
      stitchActInput.className = 'numeric-input';
      stitchActInput.value = '0';
      stitchActInput.addEventListener('input', recalcAll);
      stitchActCell.appendChild(stitchActInput);
      tr.appendChild(stitchActCell);

      // Stitching % (read-only)
      const stitchPctCell = document.createElement('td');
      stitchPctCell.textContent = '0%';
      tr.appendChild(stitchPctCell);

      // Lasting Plan
      const lastPlanCell = document.createElement('td');
      const lastPlanInput = document.createElement('input');
      lastPlanInput.type = 'number';
      lastPlanInput.min = '0';
      lastPlanInput.step = '1';
      lastPlanInput.className = 'numeric-input';
      lastPlanInput.value = '0';
      lastPlanInput.addEventListener('input', recalcAll);
      lastPlanCell.appendChild(lastPlanInput);
      tr.appendChild(lastPlanCell);

      // Lasting Actual
      const lastActCell = document.createElement('td');
      const lastActInput = document.createElement('input');
      lastActInput.type = 'number';
      lastActInput.min = '0';
      lastActInput.step = '1';
      lastActInput.className = 'numeric-input';
      lastActInput.value = '0';
      lastActInput.addEventListener('input', recalcAll);
      lastActCell.appendChild(lastActInput);
      tr.appendChild(lastActCell);

      // Lasting % (read-only)
      const lastPctCell = document.createElement('td');
      lastPctCell.textContent = '0%';
      tr.appendChild(lastPctCell);

      // Working Days (read-only)
      const wdCell = document.createElement('td');
      wdCell.textContent = '0';
      tr.appendChild(wdCell);

      // Remarks
      const remarksCell = document.createElement('td');
      const remarksInput = document.createElement('input');
      remarksInput.type = 'text';
      remarksInput.addEventListener('input', recalcAll);
      remarksCell.appendChild(remarksInput);
      tr.appendChild(remarksCell);

      // Actions
      const actionCell = document.createElement('td');
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.addEventListener('click', function() {
        tableBody.removeChild(tr);
        recalcAll();
      });
      actionCell.appendChild(delBtn);
      tr.appendChild(actionCell);

      tableBody.appendChild(tr);
    }

    /**
     * Remove all rows from the table body.
     */
    function clearRows() {
      while (tableBody.firstChild) {
        tableBody.removeChild(tableBody.firstChild);
      }
    }

    /**
     * Populate the table with predefined sample data. This will first
     * clear existing rows to avoid duplication on repeated calls.
     */
    function addSampleData() {
      clearRows();
      const samples = buildSampleRows();
      samples.forEach(sample => {
        addRow();
        const row = tableBody.lastChild;
        const cells = row.querySelectorAll('td');
        cells[1].querySelector('input').value = sample.date;
        cells[2].querySelector('input').value = sample.article;
        cells[4].querySelector('input').value = sample.cutPlan;
        cells[5].querySelector('input').value = sample.cutAct;
        cells[7].querySelector('input').value = sample.stitchPlan;
        cells[8].querySelector('input').value = sample.stitchAct;
        cells[10].querySelector('input').value = sample.lastPlan;
        cells[11].querySelector('input').value = sample.lastAct;
        cells[14].querySelector('input').value = sample.remarks;
      });
      recalcAll();
    }

    /**
     * Trigger a full recalculation of all derived values.
     */
    function recalcAll() {
      recalcWeeks();
      recalcOrderQty();
      recalcPercentages();
      recalcWorkingDays();
      updateFooterTotals();
      updateLineCharts();
    }

    /**
     * Return the short English name of a month.
     */
    function getMonthShort(monthIndex) {
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return months[monthIndex];
    }

    /**
     * Parse a date string in either yyyy-MM-dd or dd-MMM-yyyy format.
     * Returns a Date object or null if invalid.
     */
    function parseDateStr(str) {
      if (!str) return null;
      // Handle native date input format yyyy-MM-dd
      if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
        const [year, month, day] = str.split('-').map(Number);
        return new Date(year, month - 1, day);
      }
      // Fallback to dd-MMM-yyyy
      const parts = str.split('-');
      if (parts.length !== 3) return null;
      const day = parseInt(parts[0], 10);
      const monthShort = parts[1].toLowerCase();
      const year = parseInt(parts[2], 10);
      const months = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
      const monthIndex = months.indexOf(monthShort);
      if (monthIndex === -1 || isNaN(day) || isNaN(year)) return null;
      return new Date(year, monthIndex, day);
    }

    /**
     * Format a Date object as yyyy-MM-dd for native date inputs.
     */
    function formatDate(date) {
      const day = ('0' + date.getDate()).slice(-2);
      const month = ('0' + (date.getMonth() + 1)).slice(-2);
      const year = date.getFullYear();
      return `${year}-${month}-${day}`;
    }

    /**
     * Normalize user-entered dates to yyyy-MM-dd where possible.
     */
    function normalizeDateInput(event) {
      const parsed = parseDateStr(event.target.value);
      if (parsed) {
        event.target.value = formatDate(parsed);
      }
      recalcAll();
    }

    /**
     * Check if a given date occurs after today (ignoring time).
     */
    function isFutureDate(date) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const compare = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      return compare > today;
    }

    /**
     * Build 30 rows of sample data spanning the previous, current, and next month.
     */
    function buildSampleRows() {
      const now = new Date();
      const articles = ['A1', 'B2', 'C3', 'D4'];
      const monthOffsets = [-1, 0, 1];
      const rows = [];
      let idx = 0;

      monthOffsets.forEach(offset => {
        const monthDate = new Date(now.getFullYear(), now.getMonth() + offset, 1);
        const year = monthDate.getFullYear();
        const month = monthDate.getMonth();
        const totalDays = daysInMonth(year, month);

        for (let i = 0; i < 10; i++) {
          const day = (i % totalDays) + 1;
          const date = new Date(year, month, day);
          const base = 80 + idx * 5;
          const future = isFutureDate(date);
          rows.push({
            date: formatDate(date),
            article: articles[idx % articles.length],
            cutPlan: base + 20,
            cutAct: future ? 0 : base + 10,
            stitchPlan: base + 15,
            stitchAct: future ? 0 : base + 5,
            lastPlan: base + 10,
            lastAct: future ? 0 : base,
            remarks: `Sample row ${idx + 1}`
          });
          idx++;
        }
      });

      return rows;
    }

    /**
     * Determine the week label (W1–W5) given an ISO date string.
     * Returns empty string for invalid or blank dates.
     */
    function getWeekLabel(dateStr) {
      if (!dateStr) return '';
      const date = parseDateStr(dateStr);
      if (!date) return '';
      const day = date.getDate();
      const monthShort = getMonthShort(date.getMonth());
      let weekNum;
      if (day >= 1 && day <= 7) weekNum = 'W1';
      else if (day <= 14) weekNum = 'W2';
      else if (day <= 21) weekNum = 'W3';
      else if (day <= 28) weekNum = 'W4';
      else weekNum = 'W5';
      return weekNum + '-' + monthShort;
    }

    /**
     * Update the Week column for each row based on its date.
     */
    function recalcWeeks() {
      Array.from(tableBody.children).forEach(row => {
        const dateInput = row.cells[1].querySelector('input');
        const weekCell = row.cells[0];
        const weekLabel = dateInput && dateInput.value ? getWeekLabel(dateInput.value) : '';
        weekCell.textContent = weekLabel;
      });
    }

    /**
     * Calculate Order Quantity per (article, month) bucket using the max
     * of Cutting Plan, Stitching Plan, and Lasting Plan sums. Values
     * propagate to all rows belonging to the same bucket.
     */
    function recalcOrderQty() {
      const buckets = {};
      // First pass: aggregate sums
      Array.from(tableBody.children).forEach(row => {
        const article = row.cells[2].querySelector('input').value.trim().toLowerCase();
        const dateStr = row.cells[1].querySelector('input').value;
        if (!article || !dateStr) return;
        const date = parseDateStr(dateStr);
        if (!date) return;
        const key = `${article}-${date.getFullYear()}-${date.getMonth()}`;
        if (!buckets[key]) {
          buckets[key] = { cut: 0, stitch: 0, last: 0 };
        }
        const cutPlan = parseInt(row.cells[4].querySelector('input').value) || 0;
        const stitchPlan = parseInt(row.cells[7].querySelector('input').value) || 0;
        const lastPlan = parseInt(row.cells[10].querySelector('input').value) || 0;
        buckets[key].cut += cutPlan;
        buckets[key].stitch += stitchPlan;
        buckets[key].last += lastPlan;
      });
      // Second pass: assign max values
      Array.from(tableBody.children).forEach(row => {
        const oqCell = row.cells[3];
        const article = row.cells[2].querySelector('input').value.trim().toLowerCase();
        const dateStr = row.cells[1].querySelector('input').value;
        if (!article || !dateStr) {
          oqCell.textContent = '0';
          return;
        }
        const date = parseDateStr(dateStr);
        if (!date) {
          oqCell.textContent = '0';
          return;
        }
        const key = `${article}-${date.getFullYear()}-${date.getMonth()}`;
        const bucket = buckets[key];
        if (!bucket) {
          oqCell.textContent = '0';
        } else {
          const maxVal = Math.max(bucket.cut, bucket.stitch, bucket.last);
          oqCell.textContent = String(maxVal || 0);
        }
      });
    }

    /**
     * Calculate the percentage values for Cutting, Stitching, and Lasting.
     * Displays one decimal place followed by a percent sign when the
     * respective plan is greater than zero.
     */
    function recalcPercentages() {
      Array.from(tableBody.children).forEach(row => {
        // Cutting percentage
        const cutPlan = parseInt(row.cells[4].querySelector('input').value) || 0;
        const cutAct = parseInt(row.cells[5].querySelector('input').value) || 0;
        const cutPctCell = row.cells[6];
        if (cutPlan > 0) {
          const pct = (cutAct / cutPlan) * 100;
          cutPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          cutPctCell.textContent = '0%';
        }

        // Stitching percentage
        const stitchPlan = parseInt(row.cells[7].querySelector('input').value) || 0;
        const stitchAct = parseInt(row.cells[8].querySelector('input').value) || 0;
        const stitchPctCell = row.cells[9];
        if (stitchPlan > 0) {
          const pct = (stitchAct / stitchPlan) * 100;
          stitchPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          stitchPctCell.textContent = '0%';
        }

        // Lasting percentage
        const lastPlan = parseInt(row.cells[10].querySelector('input').value) || 0;
        const lastAct = parseInt(row.cells[11].querySelector('input').value) || 0;
        const lastPctCell = row.cells[12];
        if (lastPlan > 0) {
          const pct = (lastAct / lastPlan) * 100;
          lastPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          lastPctCell.textContent = '0%';
        }
      });
    }

    /**
     * Helper function to determine the number of days in a month.
     */
    function daysInMonth(year, month) {
      return new Date(year, month + 1, 0).getDate();
    }

    /**
     * Return the start date of the week bucket for a given date.
     */
    function getWeekStartDate(date) {
      const day = date.getDate();
      let startDay;
      if (day <= 7) startDay = 1;
      else if (day <= 14) startDay = 8;
      else if (day <= 21) startDay = 15;
      else if (day <= 28) startDay = 22;
      else startDay = 29;
      return new Date(date.getFullYear(), date.getMonth(), startDay);
    }

    /**
     * Build a sorted series of weekly totals for the provided plan and actual columns.
     */
    function buildPlanActualSeries(planIndex, actualIndex) {
      const buckets = new Map();
      Array.from(tableBody.children).forEach(row => {
        const dateInput = row.cells[1].querySelector('input');
        const dateStr = dateInput ? dateInput.value : '';
        const date = parseDateStr(dateStr);
        if (!date) return;
        if (selectedMonth) {
          const [year, month] = selectedMonth.split('-').map(Number);
          if (date.getFullYear() !== year || date.getMonth() + 1 !== month) {
            return;
          }
        }
        const weekLabel = row.cells[0].textContent || getWeekLabel(dateStr);
        const planVal = parseInt(row.cells[planIndex].querySelector('input').value) || 0;
        const actVal = parseInt(row.cells[actualIndex].querySelector('input').value) || 0;
        const startDate = getWeekStartDate(date);
        const key = `${weekLabel}-${startDate.toISOString()}`;
        if (!buckets.has(key)) {
          buckets.set(key, {
            label: weekLabel,
            plan: 0,
            actual: 0,
            order: startDate.getTime()
          });
        }
        const bucket = buckets.get(key);
        bucket.plan += planVal;
        bucket.actual += actVal;
      });
      return Array.from(buckets.values()).sort((a, b) => a.order - b.order);
    }

    /**
     * Render a plan vs actual line chart into the provided canvas context.
     */
    function renderLineChart(ctx, canvas, series, title) {
      if (!ctx || !canvas) return;
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      if (series.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.fillText('Add data to see plan vs actual', 10, 24);
        return;
      }

      const padding = 36;
      const maxVal = Math.max(...series.map(p => Math.max(p.plan, p.actual)), 0);
      const usableHeight = height - padding * 2;
      const usableWidth = width - padding * 2;
      const yScale = maxVal > 0 ? usableHeight / maxVal : 0;
      const xStep = series.length > 1 ? usableWidth / (series.length - 1) : 0;
      const yFor = value => height - padding - (yScale > 0 ? value * yScale : 0);

      // Axes
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();

      // Plot plan line
      ctx.strokeStyle = '#007bff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const y = yFor(point.plan);
        if (idx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Plot actual line
      ctx.strokeStyle = '#2e8b57';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const y = yFor(point.actual);
        if (idx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Plot points and labels
      ctx.font = '11px Arial';
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const planY = yFor(point.plan);
        const actY = yFor(point.actual);

        ctx.fillStyle = '#007bff';
        ctx.beginPath();
        ctx.arc(x, planY, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#2e8b57';
        ctx.beginPath();
        ctx.arc(x, actY, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#333';
        ctx.fillText(point.label, x - 14, height - padding + 14);
      });

      // Title, legend, max label, and cumulative label
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.fillText(title, padding, padding - 12);
      ctx.fillText(`${maxVal}`, 6, padding + 6);

      const cumulativePlan = series.reduce((sum, p) => sum + p.plan, 0);
      const cumulativeActual = series.reduce((sum, p) => sum + p.actual, 0);
      const cumulativePct = cumulativePlan > 0 ? ((cumulativeActual / cumulativePlan) * 100).toFixed(1) + '%' : 'N/A';
      ctx.fillText(`Cumulative Plan: ${cumulativePlan} | Actual: ${cumulativeActual} | Achievement: ${cumulativePct}`, padding, height - 6);

      const legendY = padding - 12;
      const legendX = width - padding - 110;
      ctx.fillStyle = '#007bff';
      ctx.fillRect(legendX, legendY - 8, 10, 10);
      ctx.fillStyle = '#333';
      ctx.fillText('Plan', legendX + 14, legendY);
      ctx.fillStyle = '#2e8b57';
      ctx.fillRect(legendX + 52, legendY - 8, 10, 10);
      ctx.fillStyle = '#333';
      ctx.fillText('Actual', legendX + 66, legendY);
    }

    /**
     * Update all plan vs actual line charts (Cutting, Stitching, Lasting).
     */
    function updateLineCharts() {
      chartContexts.forEach(({ ctx, canvas, cfg }) => {
        const series = buildPlanActualSeries(cfg.planIndex, cfg.actualIndex);
        renderLineChart(ctx, canvas, series, cfg.title);
      });
    }

    /**
     * Calculate working days within the week bucket for each row.
     * Friday (day index 5) is excluded; all other days count as working days.
     */
    function recalcWorkingDays() {
      Array.from(tableBody.children).forEach(row => {
        const wdCell = row.cells[13];
        const dateStr = row.cells[1].querySelector('input').value;
        if (!dateStr) {
          wdCell.textContent = '0';
          return;
        }
        const date = parseDateStr(dateStr);
        if (!date) {
          wdCell.textContent = '0';
          return;
        }
        const day = date.getDate();
        const year = date.getFullYear();
        const month = date.getMonth();
        // Determine the start of the week window within the month
        let startDay;
        if (day >= 1 && day <= 7) startDay = 1;
        else if (day <= 14) startDay = 8;
        else if (day <= 21) startDay = 15;
        else if (day <= 28) startDay = 22;
        else startDay = 29;
        const endDay = Math.min(startDay + 6, daysInMonth(year, month));
        let count = 0;
        for (let d = startDay; d <= endDay; d++) {
          const dDate = new Date(year, month, d);
          const weekday = dDate.getDay(); // Sunday=0, Friday=5
          if (weekday !== 5) {
            count++;
          }
        }
        wdCell.textContent = count;
      });
    }

    /**
     * Sum the plan and actual values for the footer totals.
     */
    function updateFooterTotals() {
      let cutPlanTotal = 0;
      let cutActTotal = 0;
      let stitchPlanTotal = 0;
      let stitchActTotal = 0;
      let lastPlanTotal = 0;
      let lastActTotal = 0;
      Array.from(tableBody.children).forEach(row => {
        cutPlanTotal += parseInt(row.cells[4].querySelector('input').value) || 0;
        cutActTotal += parseInt(row.cells[5].querySelector('input').value) || 0;
        stitchPlanTotal += parseInt(row.cells[7].querySelector('input').value) || 0;
        stitchActTotal += parseInt(row.cells[8].querySelector('input').value) || 0;
        lastPlanTotal += parseInt(row.cells[10].querySelector('input').value) || 0;
        lastActTotal += parseInt(row.cells[11].querySelector('input').value) || 0;
      });
      document.querySelector('.total-cut-plan').textContent = cutPlanTotal;
      document.querySelector('.total-cut-actual').textContent = cutActTotal;
      document.querySelector('.total-stitch-plan').textContent = stitchPlanTotal;
      document.querySelector('.total-stitch-actual').textContent = stitchActTotal;
      document.querySelector('.total-last-plan').textContent = lastPlanTotal;
      document.querySelector('.total-last-actual').textContent = lastActTotal;
    }

    /**
     * Run acceptance tests in console. Asserts key behaviours for weeks,
     * order quantities, percentages, working days and totals.
     */
    function runTests() {
      const logs = [];
      function assert(condition, message) {
        if (!condition) {
          console.error('Test failed:', message);
          logs.push('FAIL: ' + message);
        }
      }
      function isFutureDateStr(dateStr) {
        const date = parseDateStr(dateStr);
        if (!date) return false;
        return isFutureDate(date);
      }
      // Populate with sample data for testing
      const samples = buildSampleRows();
      addSampleData();
      const rows = Array.from(tableBody.children);
      function getWeek(rowIndex) {
        return rows[rowIndex].cells[0].textContent;
      }

      // 1. Sample size and date coverage
      assert(rows.length === samples.length, `Sample data should produce ${samples.length} rows`);
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();
      const prevMonthKey = (() => {
        const dt = new Date(currentYear, currentMonth - 1, 1);
        return `${dt.getFullYear()}-${dt.getMonth()}`;
      })();
      const nextMonthKey = (() => {
        const dt = new Date(currentYear, currentMonth + 1, 1);
        return `${dt.getFullYear()}-${dt.getMonth()}`;
      })();
      const monthsCovered = new Set(samples.map(sample => {
        const date = parseDateStr(sample.date);
        return date ? `${date.getFullYear()}-${date.getMonth()}` : '';
      }).filter(Boolean));
      assert(monthsCovered.has(`${currentYear}-${currentMonth}`), 'Samples should include current month');
      assert(monthsCovered.has(prevMonthKey), 'Samples should include previous month');
      assert(monthsCovered.has(nextMonthKey), 'Samples should include next month');

      // 2. Week computation
      const expectedFirstWeek = getWeekLabel(samples[0].date);
      assert(getWeek(0) === expectedFirstWeek, 'First row should reflect current month week label');

      // 3. Order Quantity logic
      function getOQ(rowIndex) {
        return parseInt(rows[rowIndex].cells[3].textContent);
      }
      const oqBuckets = samples.reduce((acc, sample) => {
        const date = parseDateStr(sample.date);
        const key = `${sample.article.toLowerCase()}-${date.getFullYear()}-${date.getMonth()}`;
        if (!acc[key]) {
          acc[key] = { cut: 0, stitch: 0, last: 0 };
        }
        acc[key].cut += sample.cutPlan;
        acc[key].stitch += sample.stitchPlan;
        acc[key].last += sample.lastPlan;
        return acc;
      }, {});
      const firstSampleKey = (() => {
        const date = parseDateStr(samples[0].date);
        return `${samples[0].article.toLowerCase()}-${date.getFullYear()}-${date.getMonth()}`;
      })();
      const expectedOQ = Math.max(...Object.values(oqBuckets[firstSampleKey]));
      assert(getOQ(0) === expectedOQ, 'Order Quantity should match max of plan sums for the article/month');

      // 4. Percentages
      function getPct(rowIndex, colIndex) {
        return rows[rowIndex].cells[colIndex].textContent;
      }
      const firstSample = samples[0];
      const expectedCutPct = ((firstSample.cutAct / firstSample.cutPlan) * 100).toFixed(1) + '%';
      const expectedStitchPct = ((firstSample.stitchAct / firstSample.stitchPlan) * 100).toFixed(1) + '%';
      const expectedLastPct = ((firstSample.lastAct / firstSample.lastPlan) * 100).toFixed(1) + '%';
      assert(getPct(0, 6) === expectedCutPct, 'Cutting% for first row should match calculated value');
      assert(getPct(0, 9) === expectedStitchPct, 'Stitching% for first row should match calculated value');
      assert(getPct(0, 12) === expectedLastPct, 'Lasting% for first row should match calculated value');

      // 5. Future-dated rows should have zero actuals
      samples.forEach((sample, idx) => {
        if (!isFutureDateStr(sample.date)) return;
        const row = rows[idx];
        const cutAct = parseInt(row.cells[5].querySelector('input').value) || 0;
        const stitchAct = parseInt(row.cells[8].querySelector('input').value) || 0;
        const lastAct = parseInt(row.cells[11].querySelector('input').value) || 0;
        assert(cutAct === 0, 'Future dates should set Cutting Actual to zero');
        assert(stitchAct === 0, 'Future dates should set Stitching Actual to zero');
        assert(lastAct === 0, 'Future dates should set Lasting Actual to zero');
      });

      // 6. Working Days (week)
      function getWD(rowIndex) {
        return parseInt(rows[rowIndex].cells[13].textContent);
      }
      function expectedWorkingDays(dateStr) {
        const date = parseDateStr(dateStr);
        const day = date.getDate();
        const year = date.getFullYear();
        const month = date.getMonth();
        let start;
        if (day <= 7) start = 1;
        else if (day <= 14) start = 8;
        else if (day <= 21) start = 15;
        else if (day <= 28) start = 22;
        else start = 29;
        const end = Math.min(start + 6, daysInMonth(year, month));
        let count = 0;
        for (let d = start; d <= end; d++) {
          const dt = new Date(year, month, d);
          if (dt.getDay() !== 5) count++;
        }
        return count;
      }
      const expectedWD = expectedWorkingDays(samples[0].date);
      assert(getWD(0) === expectedWD, 'Working days should match calculated week working days for first row');

      // 7. Footer totals
      const totals = {
        cutPlan: parseInt(document.querySelector('.total-cut-plan').textContent),
        cutAct: parseInt(document.querySelector('.total-cut-actual').textContent),
        stitchPlan: parseInt(document.querySelector('.total-stitch-plan').textContent),
        stitchAct: parseInt(document.querySelector('.total-stitch-actual').textContent),
        lastPlan: parseInt(document.querySelector('.total-last-plan').textContent),
        lastAct: parseInt(document.querySelector('.total-last-actual').textContent)
      };
      const expectedTotals = samples.reduce((acc, sample) => {
        acc.cutPlan += sample.cutPlan;
        acc.cutAct += sample.cutAct;
        acc.stitchPlan += sample.stitchPlan;
        acc.stitchAct += sample.stitchAct;
        acc.lastPlan += sample.lastPlan;
        acc.lastAct += sample.lastAct;
        return acc;
      }, { cutPlan: 0, cutAct: 0, stitchPlan: 0, stitchAct: 0, lastPlan: 0, lastAct: 0 });

      assert(totals.cutPlan === expectedTotals.cutPlan, 'Total Cutting Plan should sum sample data');
      assert(totals.cutAct === expectedTotals.cutAct, 'Total Cutting Actual should sum sample data');
      assert(totals.stitchPlan === expectedTotals.stitchPlan, 'Total Stitching Plan should sum sample data');
      assert(totals.stitchAct === expectedTotals.stitchAct, 'Total Stitching Actual should sum sample data');
      assert(totals.lastPlan === expectedTotals.lastPlan, 'Total Lasting Plan should sum sample data');
      assert(totals.lastAct === expectedTotals.lastAct, 'Total Lasting Actual should sum sample data');

      if (logs.length === 0) {
        console.log('All tests passed');
      }
    }

    /**
     * Export the table (excluding the Actions column) to an XLSX file.
     */
    function exportTable() {
      if (typeof XLSX === 'undefined') {
        alert('XLSX library not loaded');
        return;
      }

      const tableClone = document.getElementById('plannerTable').cloneNode(true);

      // Remove the Actions column
      tableClone.querySelectorAll('th:last-child, td:last-child').forEach(el => el.remove());

      // Replace inputs with their current values
      tableClone.querySelectorAll('input').forEach(input => {
        const cell = input.parentElement;
        cell.textContent = input.value;
      });

      const wb = XLSX.utils.table_to_book(tableClone, {sheet: 'Weekly Production Plan'});
      XLSX.writeFile(wb, 'weekly_production_plan.xlsx');
    }

    // Attach event listeners to toolbar buttons
    addRowBtn.addEventListener('click', function() {
      addRow();
      recalcAll();
    });
    add10RowsBtn.addEventListener('click', function() {
      for (let i = 0; i < 10; i++) {
        addRow();
      }
      recalcAll();
    });
    sampleDataBtn.addEventListener('click', function() {
      addSampleData();
    });
    runTestsBtn.addEventListener('click', function() {
      runTests();
    });
    exportBtn.addEventListener('click', function() {
      exportTable();
    });
    monthPicker.addEventListener('focus', openMonthCalendar);
    monthPicker.addEventListener('click', openMonthCalendar);
    monthPicker.addEventListener('keydown', function(event) {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        openMonthCalendar();
      } else if (event.key === 'Escape') {
        closeMonthCalendar();
      }
    });
    monthPicker.addEventListener('input', function(event) {
      applySelectedMonth(event.target.value, false);
    });

    document.addEventListener('click', function(event) {
      if (!monthCalendar.container.contains(event.target) && event.target !== monthPicker) {
        closeMonthCalendar();
      }
    });

    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        closeMonthCalendar();
      }
    });
  });
  </script>
</body>
</html>
