<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weekly Production Planner</title>
  <style>
    :root {
      --bg: #0f1115;
      --surface: #161b22;
      --surface-2: #1f2633;
      --border: #2f3645;
      --text: #e6e8ed;
      --muted: #b3b7c2;
      --accent: #7aa2f7;
      --accent-strong: #4c82ff;
      --danger: #f08c8c;
      --shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
    }

    /* Basic styling for the planner */
    body {
      font-family: Arial, sans-serif;
      color: var(--text);
      background-color: var(--bg);
      margin: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      background: var(--surface);
    }

    th, td {
      border: 1px solid var(--border);
      padding: 4px;
      text-align: left;
    }

    th {
      background-color: var(--surface-2);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    tfoot td {
      font-weight: bold;
    }

    button {
      margin-right: 5px;
      background: var(--accent);
      color: #0b1220;
      border: 1px solid var(--accent-strong);
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: background 0.2s ease, transform 0.1s ease;
    }

    button:hover,
    button:focus {
      outline: none;
      background: var(--accent-strong);
      transform: translateY(-1px);
    }

    .month-picker-input {
      width: 140px;
      cursor: pointer;
      background-color: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 6px 8px;
      border-radius: 4px;
    }

    .month-calendar {
      position: absolute;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 8px;
      border-radius: 4px;
      width: 240px;
      z-index: 10;
    }

    .month-calendar.hidden {
      display: none;
    }

    .month-calendar header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
    }

    .month-calendar .year-label {
      font-weight: bold;
      flex: 1;
      text-align: center;
    }

    .month-calendar button {
      margin: 0;
    }

    .month-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .month-grid button {
      padding: 8px 6px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
      color: var(--text);
    }

    .month-grid button:hover,
    .month-grid button:focus {
      outline: none;
      background: #23314a;
      border-color: var(--accent);
    }

    .month-grid .current-month {
      background: var(--accent-strong);
      color: #0b1220;
      border-color: var(--accent-strong);
    }

    .numeric-input {
      width: 80px;
    }

    .date-input {
      width: 150px;
    }

    .date-picker-wrapper {
      position: relative;
      display: inline-block;
    }

    .date-display {
      width: 150px;
      background-color: var(--surface);
      cursor: pointer;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 6px 8px;
      border-radius: 4px;
    }

    .native-date-input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    /* Plan chart styling */
    #chartContainer {
      width: min(1100px, calc(100% - 24px));
      margin: 16px auto 0;
      display: flex;
      gap: 12px;
      max-width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      background: var(--surface);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 8px;
      box-sizing: border-box;
    }

    .chart-panel {
      flex: 0 0 340px;
      padding: 6px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--surface-2);
    }

    .chart-panel h3 {
      margin: 4px 0 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .chart-panel canvas {
      width: 100%;
      height: 200px;
      max-width: 340px;
      display: block;
      margin: 0 auto;
    }

    /* Auth overlay */
    #loginOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 999;
    }

    #loginOverlay.hidden {
      display: none;
    }

    #loginBox {
      background: var(--surface-2);
      padding: 20px;
      border-radius: 6px;
      width: 320px;
      box-shadow: var(--shadow);
      box-sizing: border-box;
      color: var(--text);
    }

    #loginBox h2 {
      margin-top: 0;
      margin-bottom: 12px;
    }

    #loginBox label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }

    #loginBox input[type="text"],
    #loginBox input[type="password"] {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      margin-top: 4px;
      margin-bottom: 12px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
    }

    #loginError {
      color: var(--danger);
      min-height: 18px;
      margin-top: 6px;
    }

    #userStatus {
      margin-bottom: 12px;
      font-weight: bold;
      color: var(--muted);
    }

    td input,
    td textarea {
      background: var(--surface-2);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 8px;
    }

    td input:focus,
    td textarea:focus,
    .month-picker-input:focus,
    .date-display:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(122, 162, 247, 0.2);
    }

    td textarea {
      resize: vertical;
    }
  </style>
  <!-- SheetJS library for XLSX export -->
  <!-- The 0.18.7 release is not available on the CDN which caused the
       "XLSX library not loaded" alert.  Falling back to the latest version
       provided by the CDN fixes the issue. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
  <body>
  <div id="loginOverlay" role="dialog" aria-label="Sign in">
    <div id="loginBox">
      <h2>Sign in</h2>
      <form id="loginForm">
        <label for="username">Username</label>
        <input id="username" name="username" type="text" autocomplete="username" required />
        <label for="password">Password</label>
        <input id="password" name="password" type="password" autocomplete="current-password" required />
        <button type="submit">Sign in</button>
        <div id="loginError" role="alert"></div>
      </form>
    </div>
  </div>

  <div id="userStatus" aria-live="polite"></div>
  <div id="toolbar">
    <label for="monthPicker">Month: </label>
    <input
      id="monthPicker"
      type="text"
      class="month-picker-input"
      aria-label="Filter charts by month"
      placeholder="YYYY-MM"
      readonly
    />
    <button id="addRowBtn">Add Row</button>
    <button id="add10RowsBtn">Add 10 Rows</button>
    <button id="sampleDataBtn" type="button">Sample Data</button>
    <button id="runTestsBtn" type="button">Run tests</button>
    <button id="exportBtn" type="button">Export XLSX (Table Only)</button>
  </div>

  <table id="plannerTable">
    <thead>
      <tr>
        <th>Week</th>
        <th>Date</th>
        <th>Article</th>
        <th>Order Quantity</th>
        <th>Cutting Plan</th>
        <th>Cutting Actual</th>
        <th>Cutting %</th>
        <th>Stitching Plan</th>
        <th>Stitching Actual</th>
        <th>Stitching %</th>
        <th>Lasting Plan</th>
        <th>Lasting Actual</th>
        <th>Lasting %</th>
        <th>Working Days (week)</th>
        <th>Remarks</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <!-- Dynamic rows will be appended here -->
    </tbody>
    <tfoot>
      <tr>
        <td colspan="4">Grand Total</td>
        <td class="total-cut-plan">0</td>
        <td class="total-cut-actual">0</td>
        <td></td>
        <td class="total-stitch-plan">0</td>
        <td class="total-stitch-actual">0</td>
        <td></td>
        <td class="total-last-plan">0</td>
        <td class="total-last-actual">0</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
    </tfoot>
  </table>

  <div id="chartContainer" aria-label="Production plan charts">
    <div class="chart-panel" aria-label="Cutting performance chart">
      <h3>Cutting</h3>
      <canvas id="cutChart" width="340" height="200"></canvas>
    </div>
    <div class="chart-panel" aria-label="Sewing performance chart">
      <h3>Sewing</h3>
      <canvas id="stitchChart" width="340" height="200"></canvas>
    </div>
    <div class="chart-panel" aria-label="Lasting performance chart">
      <h3>Lasting</h3>
      <canvas id="lastChart" width="340" height="200"></canvas>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    const users = {
      admin: { password: 'admin123456', role: 'admin' },
      planner: { password: 'planner123456', role: 'planner' }
    };
    let currentUser = null;

    const tableBody = document.querySelector('#plannerTable tbody');
    const addRowBtn = document.getElementById('addRowBtn');
    const add10RowsBtn = document.getElementById('add10RowsBtn');
    const sampleDataBtn = document.getElementById('sampleDataBtn');
    const runTestsBtn = document.getElementById('runTestsBtn');
    const exportBtn = document.getElementById('exportBtn');
    const monthPicker = document.getElementById('monthPicker');
    const loginOverlay = document.getElementById('loginOverlay');
    const loginForm = document.getElementById('loginForm');
    const loginError = document.getElementById('loginError');
    const userStatus = document.getElementById('userStatus');
    let selectedMonth = '';
    let lastValidMonth = '';
    let calendarYear = new Date().getFullYear();
    const STORAGE_KEY = 'weekly-production-planner-state';
    let suppressPersistence = false;
    const chartConfigs = [
      { id: 'cutChart', planIndex: 4, actualIndex: 5, title: 'Plan vs Actual (Cutting)' },
      { id: 'stitchChart', planIndex: 7, actualIndex: 8, title: 'Plan vs Actual (Sewing)' },
      { id: 'lastChart', planIndex: 10, actualIndex: 11, title: 'Plan vs Actual (Lasting)' }
    ];
    const chartContexts = chartConfigs.map(cfg => {
      const canvas = document.getElementById(cfg.id);
      return { canvas, ctx: canvas ? canvas.getContext('2d') : null, cfg };
    });

    const monthCalendar = buildMonthCalendar();
    document.body.appendChild(monthCalendar.container);

    function updateUserStatus() {
      if (currentUser) {
        userStatus.textContent = `Signed in as ${currentUser.name} (${currentUser.role})`;
      } else {
        userStatus.textContent = 'Please sign in to start editing.';
      }
    }

    function isTodayDateStr(value) {
      const parsed = parseDateStr(value);
      if (!parsed) return false;
      const today = new Date();
      return (
        parsed.getFullYear() === today.getFullYear() &&
        parsed.getMonth() === today.getMonth() &&
        parsed.getDate() === today.getDate()
      );
    }

    function setInputEditable(input, editable) {
      if (!input) return;
      input.disabled = !editable;
      input.readOnly = !editable;
    }

    function applyRolePermissions() {
      updateUserStatus();
      const isAdmin = currentUser && currentUser.role === 'admin';
      const isPlanner = currentUser && currentUser.role === 'planner';

      addRowBtn.disabled = !currentUser;
      add10RowsBtn.disabled = !isAdmin;
      sampleDataBtn.disabled = !isAdmin;
      runTestsBtn.disabled = !isAdmin;
      exportBtn.disabled = !isAdmin;

      Array.from(tableBody.children).forEach(row => {
        const { displayInput, pickerInput } = getDateInputs(row);
        const articleInput = row.cells[2].querySelector('input');
        const cutPlanInput = row.cells[4].querySelector('input');
        const cutActInput = row.cells[5].querySelector('input');
        const stitchPlanInput = row.cells[7].querySelector('input');
        const stitchActInput = row.cells[8].querySelector('input');
        const lastPlanInput = row.cells[10].querySelector('input');
        const lastActInput = row.cells[11].querySelector('input');
        const remarksInput = row.cells[14].querySelector('input');
        const delBtn = row.cells[15].querySelector('button');

        if (isAdmin) {
          setDateEditable(displayInput, pickerInput, true);
          setInputEditable(articleInput, true);
          setInputEditable(cutPlanInput, true);
          setInputEditable(cutActInput, true);
          setInputEditable(stitchPlanInput, true);
          setInputEditable(stitchActInput, true);
          setInputEditable(lastPlanInput, true);
          setInputEditable(lastActInput, true);
          setInputEditable(remarksInput, true);
          if (delBtn) delBtn.disabled = false;
          return;
        }

        const allowTodayActuals = isPlanner && isTodayDateStr(getRowDateValue(row));
        setDateEditable(displayInput, pickerInput, false);
        setInputEditable(articleInput, !!allowTodayActuals);
        setInputEditable(cutPlanInput, false);
        setInputEditable(cutActInput, !!allowTodayActuals);
        setInputEditable(stitchPlanInput, false);
        setInputEditable(stitchActInput, !!allowTodayActuals);
        setInputEditable(lastPlanInput, false);
        setInputEditable(lastActInput, !!allowTodayActuals);
        setInputEditable(remarksInput, !!allowTodayActuals);
        if (delBtn) delBtn.disabled = !allowTodayActuals;
      });
    }

    function requireLogin() {
      if (!currentUser) {
        alert('Please sign in first.');
        return false;
      }
      return true;
    }

    function requireAdmin() {
      if (!requireLogin()) return false;
      if (currentUser.role !== 'admin') {
        alert('This action is available to admin only.');
        return false;
      }
      return true;
    }

    function buildMonthCalendar() {
      const container = document.createElement('div');
      container.className = 'month-calendar hidden';
      container.setAttribute('role', 'dialog');
      container.setAttribute('aria-label', 'Choose a month');

      const header = document.createElement('header');
      const prevBtn = document.createElement('button');
      prevBtn.type = 'button';
      prevBtn.textContent = '◀';
      prevBtn.addEventListener('click', () => {
        renderMonthCalendar(calendarYear - 1);
      });

      const yearLabel = document.createElement('div');
      yearLabel.className = 'year-label';
      yearLabel.textContent = calendarYear;

      const nextBtn = document.createElement('button');
      nextBtn.type = 'button';
      nextBtn.textContent = '▶';
      nextBtn.addEventListener('click', () => {
        renderMonthCalendar(calendarYear + 1);
      });

      header.appendChild(prevBtn);
      header.appendChild(yearLabel);
      header.appendChild(nextBtn);
      container.appendChild(header);

      const grid = document.createElement('div');
      grid.className = 'month-grid';

      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const monthButtons = months.map((name, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = name;
        btn.addEventListener('click', () => {
          applySelectedMonth(formatMonthValue(calendarYear, idx));
          closeMonthCalendar();
        });
        grid.appendChild(btn);
        return btn;
      });

      container.appendChild(grid);

      return { container, yearLabel, monthButtons };
    }

    function formatMonthValue(year, monthIndex) {
      return `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
    }

    function applySelectedMonth(value, updateInput = true) {
      const parsed = value ? getParsedMonth(value) : null;
      if (value && !parsed) {
        monthPicker.setCustomValidity('Please enter a month in the format YYYY-MM.');
        monthPicker.value = lastValidMonth;
        if (updateInput) {
          monthPicker.reportValidity();
        }
        return;
      }

      monthPicker.setCustomValidity('');
      selectedMonth = value || '';
      lastValidMonth = selectedMonth;
      if (updateInput) {
        monthPicker.value = selectedMonth;
      }
      updateLineCharts();
      saveState();
    }

    function getParsedMonth(value) {
      if (!value || !/^\d{4}-\d{2}$/.test(value)) return null;
      const [yearStr, monthStr] = value.split('-');
      const year = parseInt(yearStr, 10);
      const monthIndex = parseInt(monthStr, 10) - 1;
      if (isNaN(year) || isNaN(monthIndex) || monthIndex < 0 || monthIndex > 11) return null;
      return { year, monthIndex };
    }

    function renderMonthCalendar(year) {
      calendarYear = year;
      monthCalendar.yearLabel.textContent = year;
      const parsed = getParsedMonth(selectedMonth);
      const activeMonth = parsed ? parsed.monthIndex : new Date().getMonth();
      monthCalendar.monthButtons.forEach((btn, idx) => {
        btn.classList.toggle('current-month', idx === activeMonth && year === (parsed ? parsed.year : new Date().getFullYear()));
      });
    }

    function openMonthCalendar() {
      const parsed = getParsedMonth(monthPicker.value) || { year: new Date().getFullYear(), monthIndex: new Date().getMonth() };
      renderMonthCalendar(parsed.year);
      const rect = monthPicker.getBoundingClientRect();
      monthCalendar.container.style.top = `${rect.bottom + window.scrollY + 4}px`;
      monthCalendar.container.style.left = `${rect.left + window.scrollX}px`;
      monthCalendar.container.classList.remove('hidden');
      monthCalendar.monthButtons[parsed.monthIndex].focus();
    }

    function closeMonthCalendar() {
      monthCalendar.container.classList.add('hidden');
    }

    /**
     * Add a new empty row to the table. All inputs are set up
     * with appropriate event handlers to trigger recalculation.
     */
    function addRow(options = {}) {
      const tr = document.createElement('tr');
      // Week cell (read-only)
      const weekCell = document.createElement('td');
      weekCell.textContent = '';
      tr.appendChild(weekCell);

      // Date cell
      const dateCell = document.createElement('td');
      const dateWrapper = document.createElement('div');
      dateWrapper.className = 'date-picker-wrapper';

      const dateDisplay = document.createElement('input');
      dateDisplay.type = 'text';
      dateDisplay.placeholder = 'dd-MMM-yyyy';
      dateDisplay.className = 'date-input date-display';
      dateDisplay.readOnly = true;

      const dateInput = document.createElement('input');
      dateInput.type = 'date';
      dateInput.className = 'native-date-input';
      dateInput.setAttribute('aria-label', 'Choose date');

      dateInput.addEventListener('change', () => handleDateChange(dateInput, dateDisplay));
      dateInput.addEventListener('blur', () => handleDateChange(dateInput, dateDisplay));
      dateDisplay.addEventListener('click', () => {
        if (typeof dateInput.showPicker === 'function') {
          dateInput.showPicker();
        } else {
          dateInput.focus();
          dateInput.click();
        }
      });

      setDateValue(dateInput, dateDisplay, options.presetDate || '');

      dateWrapper.appendChild(dateDisplay);
      dateWrapper.appendChild(dateInput);
      dateCell.appendChild(dateWrapper);
      tr.appendChild(dateCell);

      // Article cell
      const articleCell = document.createElement('td');
      const articleInput = document.createElement('input');
      articleInput.type = 'text';
      articleInput.addEventListener('input', recalcAll);
      articleCell.appendChild(articleInput);
      tr.appendChild(articleCell);

      // Order Quantity cell (read-only, defaults to 0)
      const oqCell = document.createElement('td');
      oqCell.textContent = '0';
      tr.appendChild(oqCell);

      // Cutting Plan
      const cutPlanCell = document.createElement('td');
      const cutPlanInput = document.createElement('input');
      cutPlanInput.type = 'number';
      cutPlanInput.min = '0';
      cutPlanInput.step = '1';
      cutPlanInput.className = 'numeric-input';
      cutPlanInput.value = '0';
      cutPlanInput.addEventListener('input', recalcAll);
      cutPlanCell.appendChild(cutPlanInput);
      tr.appendChild(cutPlanCell);

      // Cutting Actual
      const cutActCell = document.createElement('td');
      const cutActInput = document.createElement('input');
      cutActInput.type = 'number';
      cutActInput.min = '0';
      cutActInput.step = '1';
      cutActInput.className = 'numeric-input';
      cutActInput.value = '0';
      cutActInput.addEventListener('input', recalcAll);
      cutActCell.appendChild(cutActInput);
      tr.appendChild(cutActCell);

      // Cutting % (read-only)
      const cutPctCell = document.createElement('td');
      cutPctCell.textContent = '0%';
      tr.appendChild(cutPctCell);

      // Stitching Plan
      const stitchPlanCell = document.createElement('td');
      const stitchPlanInput = document.createElement('input');
      stitchPlanInput.type = 'number';
      stitchPlanInput.min = '0';
      stitchPlanInput.step = '1';
      stitchPlanInput.className = 'numeric-input';
      stitchPlanInput.value = '0';
      stitchPlanInput.addEventListener('input', recalcAll);
      stitchPlanCell.appendChild(stitchPlanInput);
      tr.appendChild(stitchPlanCell);

      // Stitching Actual
      const stitchActCell = document.createElement('td');
      const stitchActInput = document.createElement('input');
      stitchActInput.type = 'number';
      stitchActInput.min = '0';
      stitchActInput.step = '1';
      stitchActInput.className = 'numeric-input';
      stitchActInput.value = '0';
      stitchActInput.addEventListener('input', recalcAll);
      stitchActCell.appendChild(stitchActInput);
      tr.appendChild(stitchActCell);

      // Stitching % (read-only)
      const stitchPctCell = document.createElement('td');
      stitchPctCell.textContent = '0%';
      tr.appendChild(stitchPctCell);

      // Lasting Plan
      const lastPlanCell = document.createElement('td');
      const lastPlanInput = document.createElement('input');
      lastPlanInput.type = 'number';
      lastPlanInput.min = '0';
      lastPlanInput.step = '1';
      lastPlanInput.className = 'numeric-input';
      lastPlanInput.value = '0';
      lastPlanInput.addEventListener('input', recalcAll);
      lastPlanCell.appendChild(lastPlanInput);
      tr.appendChild(lastPlanCell);

      // Lasting Actual
      const lastActCell = document.createElement('td');
      const lastActInput = document.createElement('input');
      lastActInput.type = 'number';
      lastActInput.min = '0';
      lastActInput.step = '1';
      lastActInput.className = 'numeric-input';
      lastActInput.value = '0';
      lastActInput.addEventListener('input', recalcAll);
      lastActCell.appendChild(lastActInput);
      tr.appendChild(lastActCell);

      // Lasting % (read-only)
      const lastPctCell = document.createElement('td');
      lastPctCell.textContent = '0%';
      tr.appendChild(lastPctCell);

      // Working Days (read-only)
      const wdCell = document.createElement('td');
      wdCell.textContent = '0';
      tr.appendChild(wdCell);

      // Remarks
      const remarksCell = document.createElement('td');
      const remarksInput = document.createElement('input');
      remarksInput.type = 'text';
      remarksInput.addEventListener('input', recalcAll);
      remarksCell.appendChild(remarksInput);
      tr.appendChild(remarksCell);

      // Actions
      const actionCell = document.createElement('td');
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.addEventListener('click', function() {
        tableBody.removeChild(tr);
        recalcAll();
      });
      actionCell.appendChild(delBtn);
      tr.appendChild(actionCell);

      tableBody.appendChild(tr);
      applyRolePermissions();
    }

    /**
     * Remove all rows from the table body.
     */
    function clearRows() {
      while (tableBody.firstChild) {
        tableBody.removeChild(tableBody.firstChild);
      }
    }

    /**
     * Populate the table with predefined sample data. This will first
     * clear existing rows to avoid duplication on repeated calls.
     */
    function addSampleData() {
      clearRows();
      const samples = buildSampleRows();
      samples.forEach(sample => {
        addRow();
        const row = tableBody.lastChild;
        const cells = row.querySelectorAll('td');
        setRowDateValue(row, sample.date);
        cells[2].querySelector('input').value = sample.article;
        cells[4].querySelector('input').value = sample.cutPlan;
        cells[5].querySelector('input').value = sample.cutAct;
        cells[7].querySelector('input').value = sample.stitchPlan;
        cells[8].querySelector('input').value = sample.stitchAct;
        cells[10].querySelector('input').value = sample.lastPlan;
        cells[11].querySelector('input').value = sample.lastAct;
        cells[14].querySelector('input').value = sample.remarks;
      });
      recalcAll();
    }

    /**
     * Trigger a full recalculation of all derived values.
     */
    function recalcAll() {
      recalcWeeks();
      recalcOrderQty();
      recalcPercentages();
      recalcWorkingDays();
      updateFooterTotals();
      updateLineCharts();
      saveState();
    }

    function getTableState() {
      return Array.from(tableBody.children).map(row => ({
        date: row.cells[1].querySelector('input').value,
        article: row.cells[2].querySelector('input').value,
        cutPlan: row.cells[4].querySelector('input').value,
        cutAct: row.cells[5].querySelector('input').value,
        stitchPlan: row.cells[7].querySelector('input').value,
        stitchAct: row.cells[8].querySelector('input').value,
        lastPlan: row.cells[10].querySelector('input').value,
        lastAct: row.cells[11].querySelector('input').value,
        remarks: row.cells[14].querySelector('input').value
      }));
    }

    function saveState() {
      if (suppressPersistence) return;
      const state = {
        selectedMonth,
        monthPickerValue: monthPicker.value,
        rows: getTableState()
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (error) {
        console.error('Unable to save plan to local storage', error);
      }
    }

    function restoreTableState(state) {
      if (!state || !Array.isArray(state.rows)) return false;
      suppressPersistence = true;
      clearRows();
      state.rows.forEach(rowData => {
        addRow();
        const cells = tableBody.lastChild.cells;
        cells[1].querySelector('input').value = rowData.date || '';
        cells[2].querySelector('input').value = rowData.article || '';
        cells[4].querySelector('input').value = rowData.cutPlan || 0;
        cells[5].querySelector('input').value = rowData.cutAct || 0;
        cells[7].querySelector('input').value = rowData.stitchPlan || 0;
        cells[8].querySelector('input').value = rowData.stitchAct || 0;
        cells[10].querySelector('input').value = rowData.lastPlan || 0;
        cells[11].querySelector('input').value = rowData.lastAct || 0;
        cells[14].querySelector('input').value = rowData.remarks || '';
      });

      const monthValue = state.selectedMonth || state.monthPickerValue || '';
      if (monthValue) {
        applySelectedMonth(monthValue);
      }
      suppressPersistence = false;
      recalcAll();
      return true;
    }

    function loadSavedState() {
      let rawState = '';
      try {
        rawState = localStorage.getItem(STORAGE_KEY) || '';
      } catch (error) {
        console.error('Unable to read saved plan from local storage', error);
        return false;
      }
      if (!rawState) return false;
      try {
        const parsed = JSON.parse(rawState);
        return restoreTableState(parsed);
      } catch (error) {
        console.error('Unable to parse saved plan from local storage', error);
        return false;
      }
    }

    /**
     * Return the short English name of a month.
     */
    function getMonthShort(monthIndex) {
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return months[monthIndex];
    }

    /**
     * Parse a date string in either yyyy-MM-dd or dd-MMM-yyyy format.
     * Returns a Date object or null if invalid.
     */
    function parseDateStr(str) {
      if (!str) return null;
      // Handle native date input format yyyy-MM-dd
      if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
        const [year, month, day] = str.split('-').map(Number);
        return new Date(year, month - 1, day);
      }
      // Fallback to dd-MMM-yyyy
      const parts = str.split('-');
      if (parts.length !== 3) return null;
      const day = parseInt(parts[0], 10);
      const monthShort = parts[1].toLowerCase();
      const year = parseInt(parts[2], 10);
      const months = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
      const monthIndex = months.indexOf(monthShort);
      if (monthIndex === -1 || isNaN(day) || isNaN(year)) return null;
      return new Date(year, monthIndex, day);
    }

    /**
     * Format a Date object as yyyy-MM-dd for native date inputs.
     */
    function formatDate(date) {
      const day = ('0' + date.getDate()).slice(-2);
      const month = ('0' + (date.getMonth() + 1)).slice(-2);
      const year = date.getFullYear();
      return `${year}-${month}-${day}`;
    }

    function formatDisplayDate(date) {
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const day = ('0' + date.getDate()).slice(-2);
      return `${day}-${months[date.getMonth()]}-${date.getFullYear()}`;
    }

    function todayFormatted() {
      return formatDate(new Date());
    }

    function syncDateDisplay(pickerInput, displayInput) {
      if (!pickerInput || !displayInput) return;
      if (pickerInput.value) {
        const parsed = parseDateStr(pickerInput.value);
        if (parsed) {
          displayInput.value = formatDisplayDate(parsed);
          displayInput.dataset.iso = pickerInput.value;
          return;
        }
      }
      displayInput.value = '';
      displayInput.dataset.iso = '';
    }

    function setDateValue(pickerInput, displayInput, value) {
      const parsed = parseDateStr(value);
      if (parsed) {
        pickerInput.value = formatDate(parsed);
      } else {
        pickerInput.value = '';
      }
      syncDateDisplay(pickerInput, displayInput);
    }

    function handleDateChange(pickerInput, displayInput) {
      syncDateDisplay(pickerInput, displayInput);
      applyRolePermissions();
      recalcAll();
    }

    function getDateInputs(row) {
      const dateCell = row.cells[1];
      return {
        displayInput: dateCell.querySelector('.date-display'),
        pickerInput: dateCell.querySelector('.native-date-input')
      };
    }

    function getRowDateValue(row) {
      const { displayInput, pickerInput } = getDateInputs(row);
      return (displayInput && displayInput.dataset.iso) || (pickerInput && pickerInput.value) || (displayInput && displayInput.value) || '';
    }

    function setDateEditable(displayInput, pickerInput, editable) {
      if (displayInput) {
        displayInput.disabled = !editable;
        displayInput.readOnly = true;
      }
      if (pickerInput) {
        pickerInput.disabled = !editable;
        pickerInput.tabIndex = editable ? 0 : -1;
      }
    }

    function setRowDateValue(row, value) {
      const { displayInput, pickerInput } = getDateInputs(row);
      if (pickerInput && displayInput) {
        setDateValue(pickerInput, displayInput, value);
      }
    }

    /**
     * Check if a given date occurs after today (ignoring time).
     */
    function isFutureDate(date) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const compare = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      return compare > today;
    }

    /**
     * Build 30 rows of sample data spanning the previous, current, and next month.
     */
    function buildSampleRows() {
      const now = new Date();
      const articles = ['A1', 'B2', 'C3', 'D4'];
      const monthOffsets = [-1, 0, 1];
      const rows = [];
      let idx = 0;

      monthOffsets.forEach(offset => {
        const monthDate = new Date(now.getFullYear(), now.getMonth() + offset, 1);
        const year = monthDate.getFullYear();
        const month = monthDate.getMonth();
        const totalDays = daysInMonth(year, month);

        for (let i = 0; i < 10; i++) {
          const day = (i % totalDays) + 1;
          const date = new Date(year, month, day);
          const base = 80 + idx * 5;
          const future = isFutureDate(date);
          rows.push({
            date: formatDate(date),
            article: articles[idx % articles.length],
            cutPlan: base + 20,
            cutAct: future ? 0 : base + 10,
            stitchPlan: base + 15,
            stitchAct: future ? 0 : base + 5,
            lastPlan: base + 10,
            lastAct: future ? 0 : base,
            remarks: `Sample row ${idx + 1}`
          });
          idx++;
        }
      });

      return rows;
    }

    /**
     * Determine the week label (W1–W5) given an ISO date string.
     * Returns empty string for invalid or blank dates.
     */
    function getWeekLabel(dateStr) {
      if (!dateStr) return '';
      const date = parseDateStr(dateStr);
      if (!date) return '';
      const day = date.getDate();
      const monthShort = getMonthShort(date.getMonth());
      let weekNum;
      if (day >= 1 && day <= 7) weekNum = 'W1';
      else if (day <= 14) weekNum = 'W2';
      else if (day <= 21) weekNum = 'W3';
      else if (day <= 28) weekNum = 'W4';
      else weekNum = 'W5';
      return weekNum + '-' + monthShort;
    }

    /**
     * Update the Week column for each row based on its date.
     */
    function recalcWeeks() {
      Array.from(tableBody.children).forEach(row => {
        const weekCell = row.cells[0];
        const dateStr = getRowDateValue(row);
        const weekLabel = dateStr ? getWeekLabel(dateStr) : '';
        weekCell.textContent = weekLabel;
      });
    }

    /**
     * Calculate Order Quantity per (article, month) bucket using the max
     * of Cutting Plan, Stitching Plan, and Lasting Plan sums. Values
     * propagate to all rows belonging to the same bucket.
     */
    function recalcOrderQty() {
      const buckets = {};
      // First pass: aggregate sums
      Array.from(tableBody.children).forEach(row => {
        const article = row.cells[2].querySelector('input').value.trim().toLowerCase();
        const dateStr = getRowDateValue(row);
        if (!article || !dateStr) return;
        const date = parseDateStr(dateStr);
        if (!date) return;
        const key = `${article}-${date.getFullYear()}-${date.getMonth()}`;
        if (!buckets[key]) {
          buckets[key] = { cut: 0, stitch: 0, last: 0 };
        }
        const cutPlan = parseInt(row.cells[4].querySelector('input').value) || 0;
        const stitchPlan = parseInt(row.cells[7].querySelector('input').value) || 0;
        const lastPlan = parseInt(row.cells[10].querySelector('input').value) || 0;
        buckets[key].cut += cutPlan;
        buckets[key].stitch += stitchPlan;
        buckets[key].last += lastPlan;
      });
      // Second pass: assign max values
      Array.from(tableBody.children).forEach(row => {
        const oqCell = row.cells[3];
        const article = row.cells[2].querySelector('input').value.trim().toLowerCase();
        const dateStr = getRowDateValue(row);
        if (!article || !dateStr) {
          oqCell.textContent = '0';
          return;
        }
        const date = parseDateStr(dateStr);
        if (!date) {
          oqCell.textContent = '0';
          return;
        }
        const key = `${article}-${date.getFullYear()}-${date.getMonth()}`;
        const bucket = buckets[key];
        if (!bucket) {
          oqCell.textContent = '0';
        } else {
          const maxVal = Math.max(bucket.cut, bucket.stitch, bucket.last);
          oqCell.textContent = String(maxVal || 0);
        }
      });
    }

    /**
     * Calculate the percentage values for Cutting, Stitching, and Lasting.
     * Displays one decimal place followed by a percent sign when the
     * respective plan is greater than zero.
     */
    function recalcPercentages() {
      Array.from(tableBody.children).forEach(row => {
        // Cutting percentage
        const cutPlan = parseInt(row.cells[4].querySelector('input').value) || 0;
        const cutAct = parseInt(row.cells[5].querySelector('input').value) || 0;
        const cutPctCell = row.cells[6];
        if (cutPlan > 0) {
          const pct = (cutAct / cutPlan) * 100;
          cutPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          cutPctCell.textContent = '0%';
        }

        // Stitching percentage
        const stitchPlan = parseInt(row.cells[7].querySelector('input').value) || 0;
        const stitchAct = parseInt(row.cells[8].querySelector('input').value) || 0;
        const stitchPctCell = row.cells[9];
        if (stitchPlan > 0) {
          const pct = (stitchAct / stitchPlan) * 100;
          stitchPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          stitchPctCell.textContent = '0%';
        }

        // Lasting percentage
        const lastPlan = parseInt(row.cells[10].querySelector('input').value) || 0;
        const lastAct = parseInt(row.cells[11].querySelector('input').value) || 0;
        const lastPctCell = row.cells[12];
        if (lastPlan > 0) {
          const pct = (lastAct / lastPlan) * 100;
          lastPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          lastPctCell.textContent = '0%';
        }
      });
    }

    /**
     * Helper function to determine the number of days in a month.
     */
    function daysInMonth(year, month) {
      return new Date(year, month + 1, 0).getDate();
    }

    /**
     * Return the start date of the week bucket for a given date.
     */
    function getWeekStartDate(date) {
      const day = date.getDate();
      let startDay;
      if (day <= 7) startDay = 1;
      else if (day <= 14) startDay = 8;
      else if (day <= 21) startDay = 15;
      else if (day <= 28) startDay = 22;
      else startDay = 29;
      return new Date(date.getFullYear(), date.getMonth(), startDay);
    }

    /**
     * Build a sorted series of weekly totals for the provided plan and actual columns.
     */
    function buildPlanActualSeries(planIndex, actualIndex) {
      const buckets = new Map();
      Array.from(tableBody.children).forEach(row => {
        const dateStr = getRowDateValue(row);
        const date = parseDateStr(dateStr);
        if (!date) return;
        if (selectedMonth) {
          const [year, month] = selectedMonth.split('-').map(Number);
          if (date.getFullYear() !== year || date.getMonth() + 1 !== month) {
            return;
          }
        }
        const weekLabel = row.cells[0].textContent || getWeekLabel(dateStr);
        const planVal = parseInt(row.cells[planIndex].querySelector('input').value) || 0;
        const actVal = parseInt(row.cells[actualIndex].querySelector('input').value) || 0;
        const startDate = getWeekStartDate(date);
        const key = `${weekLabel}-${startDate.toISOString()}`;
        if (!buckets.has(key)) {
          buckets.set(key, {
            label: weekLabel,
            plan: 0,
            actual: 0,
            order: startDate.getTime()
          });
        }
        const bucket = buckets.get(key);
        bucket.plan += planVal;
        bucket.actual += actVal;
      });
      return Array.from(buckets.values()).sort((a, b) => a.order - b.order);
    }

    /**
     * Render a plan vs actual line chart into the provided canvas context.
     */
    function renderLineChart(ctx, canvas, series, title) {
      if (!ctx || !canvas) return;
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const chartBackground = '#1f2633';
      const textColor = '#e6e8ed';
      const axisColor = '#9aa3b5';

      ctx.fillStyle = chartBackground;
      ctx.fillRect(0, 0, width, height);

      if (series.length === 0) {
        ctx.fillStyle = textColor;
        ctx.font = '12px Arial';
        ctx.fillText('Add data to see plan vs actual', 10, 24);
        return;
      }

      const padding = 36;
      const maxVal = Math.max(...series.map(p => Math.max(p.plan, p.actual)), 0);
      const usableHeight = height - padding * 2;
      const usableWidth = width - padding * 2;
      const yScale = maxVal > 0 ? usableHeight / maxVal : 0;
      const xStep = series.length > 1 ? usableWidth / (series.length - 1) : 0;
      const yFor = value => height - padding - (yScale > 0 ? value * yScale : 0);

      // Axes
      ctx.strokeStyle = axisColor;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();

      // Plot plan line
      ctx.strokeStyle = '#007bff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const y = yFor(point.plan);
        if (idx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Plot actual line
      ctx.strokeStyle = '#2e8b57';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const y = yFor(point.actual);
        if (idx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Plot points and labels
      ctx.font = '11px Arial';
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const planY = yFor(point.plan);
        const actY = yFor(point.actual);

        ctx.fillStyle = '#007bff';
        ctx.beginPath();
        ctx.arc(x, planY, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#2e8b57';
        ctx.beginPath();
        ctx.arc(x, actY, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = textColor;
        ctx.fillText(point.label, x - 14, height - padding + 14);
      });

      // Title, legend, max label, and cumulative label
      ctx.fillStyle = textColor;
      ctx.font = '12px Arial';
      ctx.fillText(title, padding, padding - 12);
      ctx.fillText(`${maxVal}`, 6, padding + 6);

      const cumulativePlan = series.reduce((sum, p) => sum + p.plan, 0);
      const cumulativeActual = series.reduce((sum, p) => sum + p.actual, 0);
      const cumulativePct = cumulativePlan > 0 ? ((cumulativeActual / cumulativePlan) * 100).toFixed(1) + '%' : 'N/A';
      ctx.fillText(`Cumulative Plan: ${cumulativePlan} | Actual: ${cumulativeActual} | Achievement: ${cumulativePct}`, padding, height - 6);

      const legendY = padding - 12;
      const legendX = width - padding - 110;
      ctx.fillStyle = '#007bff';
      ctx.fillRect(legendX, legendY - 8, 10, 10);
      ctx.fillStyle = textColor;
      ctx.fillText('Plan', legendX + 14, legendY);
      ctx.fillStyle = '#2e8b57';
      ctx.fillRect(legendX + 52, legendY - 8, 10, 10);
      ctx.fillStyle = textColor;
      ctx.fillText('Actual', legendX + 66, legendY);
    }

    /**
     * Update all plan vs actual line charts (Cutting, Stitching, Lasting).
     */
    function updateLineCharts() {
      chartContexts.forEach(({ ctx, canvas, cfg }) => {
        const series = buildPlanActualSeries(cfg.planIndex, cfg.actualIndex);
        renderLineChart(ctx, canvas, series, cfg.title);
      });
    }

    /**
     * Calculate working days within the week bucket for each row.
     * Friday (day index 5) is excluded; all other days count as working days.
     */
    function recalcWorkingDays() {
      Array.from(tableBody.children).forEach(row => {
        const wdCell = row.cells[13];
        const dateStr = getRowDateValue(row);
        if (!dateStr) {
          wdCell.textContent = '0';
          return;
        }
        const date = parseDateStr(dateStr);
        if (!date) {
          wdCell.textContent = '0';
          return;
        }
        const day = date.getDate();
        const year = date.getFullYear();
        const month = date.getMonth();
        // Determine the start of the week window within the month
        let startDay;
        if (day >= 1 && day <= 7) startDay = 1;
        else if (day <= 14) startDay = 8;
        else if (day <= 21) startDay = 15;
        else if (day <= 28) startDay = 22;
        else startDay = 29;
        const endDay = Math.min(startDay + 6, daysInMonth(year, month));
        let count = 0;
        for (let d = startDay; d <= endDay; d++) {
          const dDate = new Date(year, month, d);
          const weekday = dDate.getDay(); // Sunday=0, Friday=5
          if (weekday !== 5) {
            count++;
          }
        }
        wdCell.textContent = count;
      });
    }

    /**
     * Sum the plan and actual values for the footer totals.
     */
    function updateFooterTotals() {
      let cutPlanTotal = 0;
      let cutActTotal = 0;
      let stitchPlanTotal = 0;
      let stitchActTotal = 0;
      let lastPlanTotal = 0;
      let lastActTotal = 0;
      Array.from(tableBody.children).forEach(row => {
        cutPlanTotal += parseInt(row.cells[4].querySelector('input').value) || 0;
        cutActTotal += parseInt(row.cells[5].querySelector('input').value) || 0;
        stitchPlanTotal += parseInt(row.cells[7].querySelector('input').value) || 0;
        stitchActTotal += parseInt(row.cells[8].querySelector('input').value) || 0;
        lastPlanTotal += parseInt(row.cells[10].querySelector('input').value) || 0;
        lastActTotal += parseInt(row.cells[11].querySelector('input').value) || 0;
      });
      document.querySelector('.total-cut-plan').textContent = cutPlanTotal;
      document.querySelector('.total-cut-actual').textContent = cutActTotal;
      document.querySelector('.total-stitch-plan').textContent = stitchPlanTotal;
      document.querySelector('.total-stitch-actual').textContent = stitchActTotal;
      document.querySelector('.total-last-plan').textContent = lastPlanTotal;
      document.querySelector('.total-last-actual').textContent = lastActTotal;
    }

    /**
     * Run acceptance tests in console. Asserts key behaviours for weeks,
     * order quantities, percentages, working days and totals.
     */
    function runTests() {
      const logs = [];
      const previousState = {
        rows: getTableState(),
        selectedMonth,
        monthPickerValue: monthPicker.value
      };
      suppressPersistence = true;
      try {
        function assert(condition, message) {
          if (!condition) {
            console.error('Test failed:', message);
            logs.push('FAIL: ' + message);
          }
        }
        function isFutureDateStr(dateStr) {
          const date = parseDateStr(dateStr);
          if (!date) return false;
          return isFutureDate(date);
        }
        // Populate with sample data for testing
        const samples = buildSampleRows();
        addSampleData();
        const rows = Array.from(tableBody.children);
        function getWeek(rowIndex) {
          return rows[rowIndex].cells[0].textContent;
        }

        // 1. Sample size and date coverage
        assert(rows.length === samples.length, `Sample data should produce ${samples.length} rows`);
        const currentMonth = new Date().getMonth();
        const currentYear = new Date().getFullYear();
        const prevMonthKey = (() => {
          const dt = new Date(currentYear, currentMonth - 1, 1);
          return `${dt.getFullYear()}-${dt.getMonth()}`;
        })();
        const nextMonthKey = (() => {
          const dt = new Date(currentYear, currentMonth + 1, 1);
          return `${dt.getFullYear()}-${dt.getMonth()}`;
        })();
        const monthsCovered = new Set(samples.map(sample => {
          const date = parseDateStr(sample.date);
          return date ? `${date.getFullYear()}-${date.getMonth()}` : '';
        }).filter(Boolean));
        assert(monthsCovered.has(`${currentYear}-${currentMonth}`), 'Samples should include current month');
        assert(monthsCovered.has(prevMonthKey), 'Samples should include previous month');
        assert(monthsCovered.has(nextMonthKey), 'Samples should include next month');

        // 2. Week computation
        const expectedFirstWeek = getWeekLabel(samples[0].date);
        assert(getWeek(0) === expectedFirstWeek, 'First row should reflect current month week label');

        // 3. Order Quantity logic
        function getOQ(rowIndex) {
          return parseInt(rows[rowIndex].cells[3].textContent);
        }
        const oqBuckets = samples.reduce((acc, sample) => {
          const date = parseDateStr(sample.date);
          const key = `${sample.article.toLowerCase()}-${date.getFullYear()}-${date.getMonth()}`;
          if (!acc[key]) {
            acc[key] = { cut: 0, stitch: 0, last: 0 };
          }
          acc[key].cut += sample.cutPlan;
          acc[key].stitch += sample.stitchPlan;
          acc[key].last += sample.lastPlan;
          return acc;
        }, {});
        const firstSampleKey = (() => {
          const date = parseDateStr(samples[0].date);
          return `${samples[0].article.toLowerCase()}-${date.getFullYear()}-${date.getMonth()}`;
        })();
        const expectedOQ = Math.max(...Object.values(oqBuckets[firstSampleKey]));
        assert(getOQ(0) === expectedOQ, 'Order Quantity should match max of plan sums for the article/month');

        // 4. Percentages
        function getPct(rowIndex, colIndex) {
          return rows[rowIndex].cells[colIndex].textContent;
        }
        const firstSample = samples[0];
        const expectedCutPct = ((firstSample.cutAct / firstSample.cutPlan) * 100).toFixed(1) + '%';
        const expectedStitchPct = ((firstSample.stitchAct / firstSample.stitchPlan) * 100).toFixed(1) + '%';
        const expectedLastPct = ((firstSample.lastAct / firstSample.lastPlan) * 100).toFixed(1) + '%';
        assert(getPct(0, 6) === expectedCutPct, 'Cutting% for first row should match calculated value');
        assert(getPct(0, 9) === expectedStitchPct, 'Stitching% for first row should match calculated value');
        assert(getPct(0, 12) === expectedLastPct, 'Lasting% for first row should match calculated value');

        // 5. Future-dated rows should have zero actuals
        samples.forEach((sample, idx) => {
          if (!isFutureDateStr(sample.date)) return;
          const row = rows[idx];
          const cutAct = parseInt(row.cells[5].querySelector('input').value) || 0;
          const stitchAct = parseInt(row.cells[8].querySelector('input').value) || 0;
          const lastAct = parseInt(row.cells[11].querySelector('input').value) || 0;
          assert(cutAct === 0, 'Future dates should set Cutting Actual to zero');
          assert(stitchAct === 0, 'Future dates should set Stitching Actual to zero');
          assert(lastAct === 0, 'Future dates should set Lasting Actual to zero');
        });

        // 6. Working Days (week)
        function getWD(rowIndex) {
          return parseInt(rows[rowIndex].cells[13].textContent);
        }
        function expectedWorkingDays(dateStr) {
          const date = parseDateStr(dateStr);
          const day = date.getDate();
          const year = date.getFullYear();
          const month = date.getMonth();
          let start;
          if (day <= 7) start = 1;
          else if (day <= 14) start = 8;
          else if (day <= 21) start = 15;
          else if (day <= 28) start = 22;
          else start = 29;
          const end = Math.min(start + 6, daysInMonth(year, month));
          let count = 0;
          for (let d = start; d <= end; d++) {
            const dt = new Date(year, month, d);
            if (dt.getDay() !== 5) count++;
          }
          return count;
        }
        const expectedWD = expectedWorkingDays(samples[0].date);
        assert(getWD(0) === expectedWD, 'Working days should match calculated week working days for first row');

        // 7. Footer totals
        const totals = {
          cutPlan: parseInt(document.querySelector('.total-cut-plan').textContent),
          cutAct: parseInt(document.querySelector('.total-cut-actual').textContent),
          stitchPlan: parseInt(document.querySelector('.total-stitch-plan').textContent),
          stitchAct: parseInt(document.querySelector('.total-stitch-actual').textContent),
          lastPlan: parseInt(document.querySelector('.total-last-plan').textContent),
          lastAct: parseInt(document.querySelector('.total-last-actual').textContent)
        };
        const expectedTotals = samples.reduce((acc, sample) => {
          acc.cutPlan += sample.cutPlan;
          acc.cutAct += sample.cutAct;
          acc.stitchPlan += sample.stitchPlan;
          acc.stitchAct += sample.stitchAct;
          acc.lastPlan += sample.lastPlan;
          acc.lastAct += sample.lastAct;
          return acc;
        }, { cutPlan: 0, cutAct: 0, stitchPlan: 0, stitchAct: 0, lastPlan: 0, lastAct: 0 });

        assert(totals.cutPlan === expectedTotals.cutPlan, 'Total Cutting Plan should sum sample data');
        assert(totals.cutAct === expectedTotals.cutAct, 'Total Cutting Actual should sum sample data');
        assert(totals.stitchPlan === expectedTotals.stitchPlan, 'Total Stitching Plan should sum sample data');
        assert(totals.stitchAct === expectedTotals.stitchAct, 'Total Stitching Actual should sum sample data');
        assert(totals.lastPlan === expectedTotals.lastPlan, 'Total Lasting Plan should sum sample data');
        assert(totals.lastAct === expectedTotals.lastAct, 'Total Lasting Actual should sum sample data');

        if (logs.length === 0) {
          console.log('All tests passed');
        }
      } finally {
        suppressPersistence = false;
        restoreTableState(previousState);
      }
    }

    /**
     * Export the table (excluding the Actions column) to an XLSX file.
     */
    function exportTable() {
      if (typeof XLSX === 'undefined') {
        alert('XLSX library not loaded');
        return;
      }

      const tableClone = document.getElementById('plannerTable').cloneNode(true);

      // Remove the Actions column
      tableClone.querySelectorAll('th:last-child, td:last-child').forEach(el => el.remove());

      // Replace inputs with their current values
      tableClone.querySelectorAll('input').forEach(input => {
        const cell = input.parentElement;
        cell.textContent = input.value;
      });

      const wb = XLSX.utils.table_to_book(tableClone, {sheet: 'Weekly Production Plan'});
      XLSX.writeFile(wb, 'weekly_production_plan.xlsx');
    }

    loadSavedState();
    loginForm.addEventListener('submit', function(event) {
      event.preventDefault();
      const username = loginForm.username.value.trim();
      const password = loginForm.password.value;
      const record = users[username];
      if (!record || record.password !== password) {
        loginError.textContent = 'Invalid username or password.';
        return;
      }
      currentUser = { name: username, role: record.role };
      loginOverlay.classList.add('hidden');
      loginError.textContent = '';
      applyRolePermissions();
    });

    // Attach event listeners to toolbar buttons
    addRowBtn.addEventListener('click', function() {
      if (!requireLogin()) return;
      if (currentUser.role === 'planner') {
        addRow({ presetDate: todayFormatted() });
      } else {
        addRow();
      }
      recalcAll();
    });
    add10RowsBtn.addEventListener('click', function() {
      if (!requireAdmin()) return;
      for (let i = 0; i < 10; i++) {
        addRow();
      }
      recalcAll();
    });
    sampleDataBtn.addEventListener('click', function() {
      if (!requireAdmin()) return;
      addSampleData();
    });
    runTestsBtn.addEventListener('click', function() {
      if (!requireAdmin()) return;
      runTests();
    });
    exportBtn.addEventListener('click', function() {
      if (!requireAdmin()) return;
      exportTable();
    });
    monthPicker.addEventListener('focus', openMonthCalendar);
    monthPicker.addEventListener('click', openMonthCalendar);
    monthPicker.addEventListener('keydown', function(event) {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        openMonthCalendar();
      } else if (event.key === 'Escape') {
        closeMonthCalendar();
      }
    });
    monthPicker.addEventListener('input', function(event) {
      applySelectedMonth(event.target.value, false);
    });

    document.addEventListener('click', function(event) {
      if (!monthCalendar.container.contains(event.target) && event.target !== monthPicker) {
        closeMonthCalendar();
      }
    });

    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        closeMonthCalendar();
      }
    });

    applyRolePermissions();
  });
  </script>
</body>
</html>
