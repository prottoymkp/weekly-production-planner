<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weekly Production Planner</title>
  <style>
    /* Basic styling for the planner */
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      border: 1px solid #ccc;
      padding: 4px;
      text-align: left;
    }

    th {
      background-color: #f2f2f2;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    tfoot td {
      font-weight: bold;
    }

    button {
      margin-right: 5px;
    }

    .numeric-input {
      width: 80px;
    }

    .date-input {
      width: 150px;
    }

    /* Plan chart styling */
    #chartContainer {
      position: fixed;
      bottom: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      gap: 12px;
      max-height: 80vh;
      overflow-x: auto;
      overflow-y: hidden;
      background: #fff;
      border: 1px solid #ddd;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      padding: 8px;
      box-sizing: border-box;
      z-index: 2;
    }

    .chart-panel {
      flex: 1 0 320px;
      padding: 6px;
      border: 1px solid #eee;
      border-radius: 4px;
      background: #fafafa;
    }

    .chart-panel h3 {
      margin: 4px 0 8px;
      font-size: 14px;
      font-weight: bold;
    }

    .chart-panel canvas {
      width: 100%;
      height: 200px;
      display: block;
    }
  </style>
  <!-- SheetJS library for XLSX export -->
  <!-- The 0.18.7 release is not available on the CDN which caused the
       "XLSX library not loaded" alert.  Falling back to the latest version
       provided by the CDN fixes the issue. -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <div id="toolbar">
    <button id="addRowBtn">Add Row</button>
    <button id="add10RowsBtn">Add 10 Rows</button>
    <button id="sampleDataBtn" type="button">Sample Data</button>
    <button id="runTestsBtn" type="button">Run tests</button>
    <button id="exportBtn" type="button">Export XLSX (Table Only)</button>
  </div>

  <table id="plannerTable">
    <thead>
      <tr>
        <th>Week</th>
        <th>Date</th>
        <th>Article</th>
        <th>Order Quantity</th>
        <th>Cutting Plan</th>
        <th>Cutting Actual</th>
        <th>Cutting %</th>
        <th>Stitching Plan</th>
        <th>Stitching Actual</th>
        <th>Stitching %</th>
        <th>Lasting Plan</th>
        <th>Lasting Actual</th>
        <th>Lasting %</th>
        <th>Working Days (week)</th>
        <th>Remarks</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      <!-- Dynamic rows will be appended here -->
    </tbody>
    <tfoot>
      <tr>
        <td colspan="4">Grand Total</td>
        <td class="total-cut-plan">0</td>
        <td class="total-cut-actual">0</td>
        <td></td>
        <td class="total-stitch-plan">0</td>
        <td class="total-stitch-actual">0</td>
        <td></td>
        <td class="total-last-plan">0</td>
        <td class="total-last-actual">0</td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
      </tr>
    </tfoot>
  </table>

  <div id="chartContainer" aria-label="Production plan charts">
    <div class="chart-panel" aria-label="Cutting performance chart">
      <h3>Cutting</h3>
      <canvas id="cutChart" width="340" height="200"></canvas>
    </div>
    <div class="chart-panel" aria-label="Sewing performance chart">
      <h3>Sewing</h3>
      <canvas id="stitchChart" width="340" height="200"></canvas>
    </div>
    <div class="chart-panel" aria-label="Lasting performance chart">
      <h3>Lasting</h3>
      <canvas id="lastChart" width="340" height="200"></canvas>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function() {
    const tableBody = document.querySelector('#plannerTable tbody');
    const addRowBtn = document.getElementById('addRowBtn');
    const add10RowsBtn = document.getElementById('add10RowsBtn');
    const sampleDataBtn = document.getElementById('sampleDataBtn');
    const runTestsBtn = document.getElementById('runTestsBtn');
    const exportBtn = document.getElementById('exportBtn');
    const chartConfigs = [
      { id: 'cutChart', planIndex: 4, actualIndex: 5, title: 'Plan vs Actual (Cutting)' },
      { id: 'stitchChart', planIndex: 7, actualIndex: 8, title: 'Plan vs Actual (Sewing)' },
      { id: 'lastChart', planIndex: 10, actualIndex: 11, title: 'Plan vs Actual (Lasting)' }
    ];
    const chartContexts = chartConfigs.map(cfg => {
      const canvas = document.getElementById(cfg.id);
      return { canvas, ctx: canvas ? canvas.getContext('2d') : null, cfg };
    });

    /**
     * Add a new empty row to the table. All inputs are set up
     * with appropriate event handlers to trigger recalculation.
     */
    function addRow() {
      const tr = document.createElement('tr');
      // Week cell (read-only)
      const weekCell = document.createElement('td');
      weekCell.textContent = '';
      tr.appendChild(weekCell);

      // Date cell
      const dateCell = document.createElement('td');
      const dateInput = document.createElement('input');
      dateInput.type = 'date';
      dateInput.className = 'date-input';
      dateInput.addEventListener('input', recalcAll);
      dateCell.appendChild(dateInput);
      tr.appendChild(dateCell);

      // Article cell
      const articleCell = document.createElement('td');
      const articleInput = document.createElement('input');
      articleInput.type = 'text';
      articleInput.addEventListener('input', recalcAll);
      articleCell.appendChild(articleInput);
      tr.appendChild(articleCell);

      // Order Quantity cell (read-only, defaults to 0)
      const oqCell = document.createElement('td');
      oqCell.textContent = '0';
      tr.appendChild(oqCell);

      // Cutting Plan
      const cutPlanCell = document.createElement('td');
      const cutPlanInput = document.createElement('input');
      cutPlanInput.type = 'number';
      cutPlanInput.min = '0';
      cutPlanInput.step = '1';
      cutPlanInput.className = 'numeric-input';
      cutPlanInput.value = '0';
      cutPlanInput.addEventListener('input', recalcAll);
      cutPlanCell.appendChild(cutPlanInput);
      tr.appendChild(cutPlanCell);

      // Cutting Actual
      const cutActCell = document.createElement('td');
      const cutActInput = document.createElement('input');
      cutActInput.type = 'number';
      cutActInput.min = '0';
      cutActInput.step = '1';
      cutActInput.className = 'numeric-input';
      cutActInput.value = '0';
      cutActInput.addEventListener('input', recalcAll);
      cutActCell.appendChild(cutActInput);
      tr.appendChild(cutActCell);

      // Cutting % (read-only)
      const cutPctCell = document.createElement('td');
      cutPctCell.textContent = '0%';
      tr.appendChild(cutPctCell);

      // Stitching Plan
      const stitchPlanCell = document.createElement('td');
      const stitchPlanInput = document.createElement('input');
      stitchPlanInput.type = 'number';
      stitchPlanInput.min = '0';
      stitchPlanInput.step = '1';
      stitchPlanInput.className = 'numeric-input';
      stitchPlanInput.value = '0';
      stitchPlanInput.addEventListener('input', recalcAll);
      stitchPlanCell.appendChild(stitchPlanInput);
      tr.appendChild(stitchPlanCell);

      // Stitching Actual
      const stitchActCell = document.createElement('td');
      const stitchActInput = document.createElement('input');
      stitchActInput.type = 'number';
      stitchActInput.min = '0';
      stitchActInput.step = '1';
      stitchActInput.className = 'numeric-input';
      stitchActInput.value = '0';
      stitchActInput.addEventListener('input', recalcAll);
      stitchActCell.appendChild(stitchActInput);
      tr.appendChild(stitchActCell);

      // Stitching % (read-only)
      const stitchPctCell = document.createElement('td');
      stitchPctCell.textContent = '0%';
      tr.appendChild(stitchPctCell);

      // Lasting Plan
      const lastPlanCell = document.createElement('td');
      const lastPlanInput = document.createElement('input');
      lastPlanInput.type = 'number';
      lastPlanInput.min = '0';
      lastPlanInput.step = '1';
      lastPlanInput.className = 'numeric-input';
      lastPlanInput.value = '0';
      lastPlanInput.addEventListener('input', recalcAll);
      lastPlanCell.appendChild(lastPlanInput);
      tr.appendChild(lastPlanCell);

      // Lasting Actual
      const lastActCell = document.createElement('td');
      const lastActInput = document.createElement('input');
      lastActInput.type = 'number';
      lastActInput.min = '0';
      lastActInput.step = '1';
      lastActInput.className = 'numeric-input';
      lastActInput.value = '0';
      lastActInput.addEventListener('input', recalcAll);
      lastActCell.appendChild(lastActInput);
      tr.appendChild(lastActCell);

      // Lasting % (read-only)
      const lastPctCell = document.createElement('td');
      lastPctCell.textContent = '0%';
      tr.appendChild(lastPctCell);

      // Working Days (read-only)
      const wdCell = document.createElement('td');
      wdCell.textContent = '0';
      tr.appendChild(wdCell);

      // Remarks
      const remarksCell = document.createElement('td');
      const remarksInput = document.createElement('input');
      remarksInput.type = 'text';
      remarksInput.addEventListener('input', recalcAll);
      remarksCell.appendChild(remarksInput);
      tr.appendChild(remarksCell);

      // Actions
      const actionCell = document.createElement('td');
      const delBtn = document.createElement('button');
      delBtn.textContent = 'Delete';
      delBtn.addEventListener('click', function() {
        tableBody.removeChild(tr);
        recalcAll();
      });
      actionCell.appendChild(delBtn);
      tr.appendChild(actionCell);

      tableBody.appendChild(tr);
    }

    /**
     * Remove all rows from the table body.
     */
    function clearRows() {
      while (tableBody.firstChild) {
        tableBody.removeChild(tableBody.firstChild);
      }
    }

    /**
     * Populate the table with predefined sample data. This will first
     * clear existing rows to avoid duplication on repeated calls.
     */
    function addSampleData() {
      clearRows();
      const samples = buildSampleRows();
      samples.forEach(sample => {
        addRow();
        const row = tableBody.lastChild;
        const cells = row.querySelectorAll('td');
        cells[1].querySelector('input').value = sample.date;
        cells[2].querySelector('input').value = sample.article;
        cells[4].querySelector('input').value = sample.cutPlan;
        cells[5].querySelector('input').value = sample.cutAct;
        cells[7].querySelector('input').value = sample.stitchPlan;
        cells[8].querySelector('input').value = sample.stitchAct;
        cells[10].querySelector('input').value = sample.lastPlan;
        cells[11].querySelector('input').value = sample.lastAct;
        cells[14].querySelector('input').value = sample.remarks;
      });
      recalcAll();
    }

    /**
     * Trigger a full recalculation of all derived values.
     */
    function recalcAll() {
      recalcWeeks();
      recalcOrderQty();
      recalcPercentages();
      recalcWorkingDays();
      updateFooterTotals();
      updateLineCharts();
    }

    /**
     * Return the short English name of a month.
     */
    function getMonthShort(monthIndex) {
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return months[monthIndex];
    }

    /**
     * Parse a date string in either yyyy-MM-dd or dd-MMM-yyyy format.
     * Returns a Date object or null if invalid.
     */
    function parseDateStr(str) {
      if (!str) return null;
      // Handle native date input format yyyy-MM-dd
      if (/^\d{4}-\d{2}-\d{2}$/.test(str)) {
        const [year, month, day] = str.split('-').map(Number);
        return new Date(year, month - 1, day);
      }
      // Fallback to dd-MMM-yyyy
      const parts = str.split('-');
      if (parts.length !== 3) return null;
      const day = parseInt(parts[0], 10);
      const monthShort = parts[1].toLowerCase();
      const year = parseInt(parts[2], 10);
      const months = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
      const monthIndex = months.indexOf(monthShort);
      if (monthIndex === -1 || isNaN(day) || isNaN(year)) return null;
      return new Date(year, monthIndex, day);
    }

    /**
     * Format a Date object as dd-MMM-yyyy.
     */
    function formatDate(date) {
      const day = ('0' + date.getDate()).slice(-2);
      const monthShort = getMonthShort(date.getMonth());
      const year = date.getFullYear();
      return `${day}-${monthShort}-${year}`;
    }

    /**
     * Format a Date object as yyyy-MM-dd for use with date inputs.
     */
    function formatInputDate(date) {
      const day = ('0' + date.getDate()).slice(-2);
      const month = ('0' + (date.getMonth() + 1)).slice(-2);
      const year = date.getFullYear();
      return `${year}-${month}-${day}`;
    }

    /**
     * Build 20 rows of sample data using dates from the current month.
     */
    function buildSampleRows() {
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth();
      const totalDays = daysInMonth(year, month);
      const articles = ['A1', 'B2', 'C3', 'D4'];

      return Array.from({ length: 20 }, (_, idx) => {
        const day = (idx % totalDays) + 1;
        const date = new Date(year, month, day);
        const base = 80 + idx * 5;
        return {
          date: formatInputDate(date),
          article: articles[idx % articles.length],
          cutPlan: base + 20,
          cutAct: base + 10,
          stitchPlan: base + 15,
          stitchAct: base + 5,
          lastPlan: base + 10,
          lastAct: base,
          remarks: `Sample row ${idx + 1}`
        };
      });
    }

    /**
     * Determine the week label (W1â€“W5) given an ISO date string.
     * Returns empty string for invalid or blank dates.
     */
    function getWeekLabel(dateStr) {
      if (!dateStr) return '';
      const date = parseDateStr(dateStr);
      if (!date) return '';
      const day = date.getDate();
      const monthShort = getMonthShort(date.getMonth());
      let weekNum;
      if (day >= 1 && day <= 7) weekNum = 'W1';
      else if (day <= 14) weekNum = 'W2';
      else if (day <= 21) weekNum = 'W3';
      else if (day <= 28) weekNum = 'W4';
      else weekNum = 'W5';
      return weekNum + '-' + monthShort;
    }

    /**
     * Update the Week column for each row based on its date.
     */
    function recalcWeeks() {
      Array.from(tableBody.children).forEach(row => {
        const dateInput = row.cells[1].querySelector('input');
        const weekCell = row.cells[0];
        const weekLabel = dateInput && dateInput.value ? getWeekLabel(dateInput.value) : '';
        weekCell.textContent = weekLabel;
      });
    }

    /**
     * Calculate Order Quantity per (article, month) bucket using the max
     * of Cutting Plan, Stitching Plan, and Lasting Plan sums. Values
     * propagate to all rows belonging to the same bucket.
     */
    function recalcOrderQty() {
      const buckets = {};
      // First pass: aggregate sums
      Array.from(tableBody.children).forEach(row => {
        const article = row.cells[2].querySelector('input').value.trim().toLowerCase();
        const dateStr = row.cells[1].querySelector('input').value;
        if (!article || !dateStr) return;
        const date = parseDateStr(dateStr);
        if (!date) return;
        const key = `${article}-${date.getFullYear()}-${date.getMonth()}`;
        if (!buckets[key]) {
          buckets[key] = { cut: 0, stitch: 0, last: 0 };
        }
        const cutPlan = parseInt(row.cells[4].querySelector('input').value) || 0;
        const stitchPlan = parseInt(row.cells[7].querySelector('input').value) || 0;
        const lastPlan = parseInt(row.cells[10].querySelector('input').value) || 0;
        buckets[key].cut += cutPlan;
        buckets[key].stitch += stitchPlan;
        buckets[key].last += lastPlan;
      });
      // Second pass: assign max values
      Array.from(tableBody.children).forEach(row => {
        const oqCell = row.cells[3];
        const article = row.cells[2].querySelector('input').value.trim().toLowerCase();
        const dateStr = row.cells[1].querySelector('input').value;
        if (!article || !dateStr) {
          oqCell.textContent = '0';
          return;
        }
        const date = parseDateStr(dateStr);
        if (!date) {
          oqCell.textContent = '0';
          return;
        }
        const key = `${article}-${date.getFullYear()}-${date.getMonth()}`;
        const bucket = buckets[key];
        if (!bucket) {
          oqCell.textContent = '0';
        } else {
          const maxVal = Math.max(bucket.cut, bucket.stitch, bucket.last);
          oqCell.textContent = String(maxVal || 0);
        }
      });
    }

    /**
     * Calculate the percentage values for Cutting, Stitching, and Lasting.
     * Displays one decimal place followed by a percent sign when the
     * respective plan is greater than zero.
     */
    function recalcPercentages() {
      Array.from(tableBody.children).forEach(row => {
        // Cutting percentage
        const cutPlan = parseInt(row.cells[4].querySelector('input').value) || 0;
        const cutAct = parseInt(row.cells[5].querySelector('input').value) || 0;
        const cutPctCell = row.cells[6];
        if (cutPlan > 0) {
          const pct = (cutAct / cutPlan) * 100;
          cutPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          cutPctCell.textContent = '0%';
        }

        // Stitching percentage
        const stitchPlan = parseInt(row.cells[7].querySelector('input').value) || 0;
        const stitchAct = parseInt(row.cells[8].querySelector('input').value) || 0;
        const stitchPctCell = row.cells[9];
        if (stitchPlan > 0) {
          const pct = (stitchAct / stitchPlan) * 100;
          stitchPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          stitchPctCell.textContent = '0%';
        }

        // Lasting percentage
        const lastPlan = parseInt(row.cells[10].querySelector('input').value) || 0;
        const lastAct = parseInt(row.cells[11].querySelector('input').value) || 0;
        const lastPctCell = row.cells[12];
        if (lastPlan > 0) {
          const pct = (lastAct / lastPlan) * 100;
          lastPctCell.textContent = pct.toFixed(1) + '%';
        } else {
          lastPctCell.textContent = '0%';
        }
      });
    }

    /**
     * Helper function to determine the number of days in a month.
     */
    function daysInMonth(year, month) {
      return new Date(year, month + 1, 0).getDate();
    }

    /**
     * Return the start date of the week bucket for a given date.
     */
    function getWeekStartDate(date) {
      const day = date.getDate();
      let startDay;
      if (day <= 7) startDay = 1;
      else if (day <= 14) startDay = 8;
      else if (day <= 21) startDay = 15;
      else if (day <= 28) startDay = 22;
      else startDay = 29;
      return new Date(date.getFullYear(), date.getMonth(), startDay);
    }

    /**
     * Build a sorted series of weekly totals for the provided plan and actual columns.
     */
    function buildPlanActualSeries(planIndex, actualIndex) {
      const buckets = new Map();
      Array.from(tableBody.children).forEach(row => {
        const dateInput = row.cells[1].querySelector('input');
        const dateStr = dateInput ? dateInput.value : '';
        const date = parseDateStr(dateStr);
        if (!date) return;
        const weekLabel = row.cells[0].textContent || getWeekLabel(dateStr);
        const planVal = parseInt(row.cells[planIndex].querySelector('input').value) || 0;
        const actVal = parseInt(row.cells[actualIndex].querySelector('input').value) || 0;
        const startDate = getWeekStartDate(date);
        const key = `${weekLabel}-${startDate.toISOString()}`;
        if (!buckets.has(key)) {
          buckets.set(key, {
            label: weekLabel,
            plan: 0,
            actual: 0,
            order: startDate.getTime()
          });
        }
        const bucket = buckets.get(key);
        bucket.plan += planVal;
        bucket.actual += actVal;
      });
      return Array.from(buckets.values()).sort((a, b) => a.order - b.order);
    }

    /**
     * Render a plan vs actual line chart into the provided canvas context.
     */
    function renderLineChart(ctx, canvas, series, title) {
      if (!ctx || !canvas) return;
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      if (series.length === 0) {
        ctx.fillStyle = '#666';
        ctx.font = '12px Arial';
        ctx.fillText('Add data to see plan vs actual', 10, 24);
        return;
      }

      const padding = 36;
      const maxVal = Math.max(...series.map(p => Math.max(p.plan, p.actual)), 0);
      const usableHeight = height - padding * 2;
      const usableWidth = width - padding * 2;
      const yScale = maxVal > 0 ? usableHeight / maxVal : 0;
      const xStep = series.length > 1 ? usableWidth / (series.length - 1) : 0;
      const yFor = value => height - padding - (yScale > 0 ? value * yScale : 0);

      // Axes
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();

      // Plot plan line
      ctx.strokeStyle = '#007bff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const y = yFor(point.plan);
        if (idx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Plot actual line
      ctx.strokeStyle = '#2e8b57';
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const y = yFor(point.actual);
        if (idx === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Plot points and labels
      ctx.font = '11px Arial';
      series.forEach((point, idx) => {
        const x = padding + idx * xStep;
        const planY = yFor(point.plan);
        const actY = yFor(point.actual);

        ctx.fillStyle = '#007bff';
        ctx.beginPath();
        ctx.arc(x, planY, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#2e8b57';
        ctx.beginPath();
        ctx.arc(x, actY, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#333';
        ctx.fillText(point.label, x - 14, height - padding + 14);
      });

      // Title, legend, and max label
      ctx.fillStyle = '#333';
      ctx.font = '12px Arial';
      ctx.fillText(title, padding, padding - 12);
      ctx.fillText(`${maxVal}`, 6, padding + 6);

      const legendY = padding - 12;
      const legendX = width - padding - 110;
      ctx.fillStyle = '#007bff';
      ctx.fillRect(legendX, legendY - 8, 10, 10);
      ctx.fillStyle = '#333';
      ctx.fillText('Plan', legendX + 14, legendY);
      ctx.fillStyle = '#2e8b57';
      ctx.fillRect(legendX + 52, legendY - 8, 10, 10);
      ctx.fillStyle = '#333';
      ctx.fillText('Actual', legendX + 66, legendY);
    }

    /**
     * Update all plan vs actual line charts (Cutting, Stitching, Lasting).
     */
    function updateLineCharts() {
      chartContexts.forEach(({ ctx, canvas, cfg }) => {
        const series = buildPlanActualSeries(cfg.planIndex, cfg.actualIndex);
        renderLineChart(ctx, canvas, series, cfg.title);
      });
    }

    /**
     * Calculate working days within the week bucket for each row.
     * Friday (day index 5) is excluded; all other days count as working days.
     */
    function recalcWorkingDays() {
      Array.from(tableBody.children).forEach(row => {
        const wdCell = row.cells[13];
        const dateStr = row.cells[1].querySelector('input').value;
        if (!dateStr) {
          wdCell.textContent = '0';
          return;
        }
        const date = parseDateStr(dateStr);
        if (!date) {
          wdCell.textContent = '0';
          return;
        }
        const day = date.getDate();
        const year = date.getFullYear();
        const month = date.getMonth();
        // Determine the start of the week window within the month
        let startDay;
        if (day >= 1 && day <= 7) startDay = 1;
        else if (day <= 14) startDay = 8;
        else if (day <= 21) startDay = 15;
        else if (day <= 28) startDay = 22;
        else startDay = 29;
        const endDay = Math.min(startDay + 6, daysInMonth(year, month));
        let count = 0;
        for (let d = startDay; d <= endDay; d++) {
          const dDate = new Date(year, month, d);
          const weekday = dDate.getDay(); // Sunday=0, Friday=5
          if (weekday !== 5) {
            count++;
          }
        }
        wdCell.textContent = count;
      });
    }

    /**
     * Sum the plan and actual values for the footer totals.
     */
    function updateFooterTotals() {
      let cutPlanTotal = 0;
      let cutActTotal = 0;
      let stitchPlanTotal = 0;
      let stitchActTotal = 0;
      let lastPlanTotal = 0;
      let lastActTotal = 0;
      Array.from(tableBody.children).forEach(row => {
        cutPlanTotal += parseInt(row.cells[4].querySelector('input').value) || 0;
        cutActTotal += parseInt(row.cells[5].querySelector('input').value) || 0;
        stitchPlanTotal += parseInt(row.cells[7].querySelector('input').value) || 0;
        stitchActTotal += parseInt(row.cells[8].querySelector('input').value) || 0;
        lastPlanTotal += parseInt(row.cells[10].querySelector('input').value) || 0;
        lastActTotal += parseInt(row.cells[11].querySelector('input').value) || 0;
      });
      document.querySelector('.total-cut-plan').textContent = cutPlanTotal;
      document.querySelector('.total-cut-actual').textContent = cutActTotal;
      document.querySelector('.total-stitch-plan').textContent = stitchPlanTotal;
      document.querySelector('.total-stitch-actual').textContent = stitchActTotal;
      document.querySelector('.total-last-plan').textContent = lastPlanTotal;
      document.querySelector('.total-last-actual').textContent = lastActTotal;
    }

    /**
     * Run acceptance tests in console. Asserts key behaviours for weeks,
     * order quantities, percentages, working days and totals.
     */
    function runTests() {
      const logs = [];
      function assert(condition, message) {
        if (!condition) {
          console.error('Test failed:', message);
          logs.push('FAIL: ' + message);
        }
      }
      // Populate with sample data for testing
      const samples = buildSampleRows();
      addSampleData();
      const rows = Array.from(tableBody.children);
      function getWeek(rowIndex) {
        return rows[rowIndex].cells[0].textContent;
      }

      // 1. Sample size and date coverage
      assert(rows.length === samples.length, 'Sample data should produce 20 rows');
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();
      const allDatesCurrentMonth = samples.every(sample => {
        const date = parseDateStr(sample.date);
        return date && date.getMonth() === currentMonth && date.getFullYear() === currentYear;
      });
      assert(allDatesCurrentMonth, 'All sample dates should be in the current month and year');

      // 2. Week computation
      const expectedFirstWeek = getWeekLabel(samples[0].date);
      assert(getWeek(0) === expectedFirstWeek, 'First row should reflect current month week label');

      // 3. Order Quantity logic
      function getOQ(rowIndex) {
        return parseInt(rows[rowIndex].cells[3].textContent);
      }
      const oqBuckets = samples.reduce((acc, sample) => {
        const date = parseDateStr(sample.date);
        const key = `${sample.article.toLowerCase()}-${date.getFullYear()}-${date.getMonth()}`;
        if (!acc[key]) {
          acc[key] = { cut: 0, stitch: 0, last: 0 };
        }
        acc[key].cut += sample.cutPlan;
        acc[key].stitch += sample.stitchPlan;
        acc[key].last += sample.lastPlan;
        return acc;
      }, {});
      const firstSampleKey = (() => {
        const date = parseDateStr(samples[0].date);
        return `${samples[0].article.toLowerCase()}-${date.getFullYear()}-${date.getMonth()}`;
      })();
      const expectedOQ = Math.max(...Object.values(oqBuckets[firstSampleKey]));
      assert(getOQ(0) === expectedOQ, 'Order Quantity should match max of plan sums for the article/month');

      // 4. Percentages
      function getPct(rowIndex, colIndex) {
        return rows[rowIndex].cells[colIndex].textContent;
      }
      const firstSample = samples[0];
      const expectedCutPct = ((firstSample.cutAct / firstSample.cutPlan) * 100).toFixed(1) + '%';
      const expectedStitchPct = ((firstSample.stitchAct / firstSample.stitchPlan) * 100).toFixed(1) + '%';
      const expectedLastPct = ((firstSample.lastAct / firstSample.lastPlan) * 100).toFixed(1) + '%';
      assert(getPct(0, 6) === expectedCutPct, 'Cutting% for first row should match calculated value');
      assert(getPct(0, 9) === expectedStitchPct, 'Stitching% for first row should match calculated value');
      assert(getPct(0, 12) === expectedLastPct, 'Lasting% for first row should match calculated value');

      // 5. Working Days (week)
      function getWD(rowIndex) {
        return parseInt(rows[rowIndex].cells[13].textContent);
      }
      function expectedWorkingDays(dateStr) {
        const date = parseDateStr(dateStr);
        const day = date.getDate();
        const year = date.getFullYear();
        const month = date.getMonth();
        let start;
        if (day <= 7) start = 1;
        else if (day <= 14) start = 8;
        else if (day <= 21) start = 15;
        else if (day <= 28) start = 22;
        else start = 29;
        const end = Math.min(start + 6, daysInMonth(year, month));
        let count = 0;
        for (let d = start; d <= end; d++) {
          const dt = new Date(year, month, d);
          if (dt.getDay() !== 5) count++;
        }
        return count;
      }
      const expectedWD = expectedWorkingDays(samples[0].date);
      assert(getWD(0) === expectedWD, 'Working days should match calculated week working days for first row');

      // 6. Footer totals
      const totals = {
        cutPlan: parseInt(document.querySelector('.total-cut-plan').textContent),
        cutAct: parseInt(document.querySelector('.total-cut-actual').textContent),
        stitchPlan: parseInt(document.querySelector('.total-stitch-plan').textContent),
        stitchAct: parseInt(document.querySelector('.total-stitch-actual').textContent),
        lastPlan: parseInt(document.querySelector('.total-last-plan').textContent),
        lastAct: parseInt(document.querySelector('.total-last-actual').textContent)
      };
      const expectedTotals = samples.reduce((acc, sample) => {
        acc.cutPlan += sample.cutPlan;
        acc.cutAct += sample.cutAct;
        acc.stitchPlan += sample.stitchPlan;
        acc.stitchAct += sample.stitchAct;
        acc.lastPlan += sample.lastPlan;
        acc.lastAct += sample.lastAct;
        return acc;
      }, { cutPlan: 0, cutAct: 0, stitchPlan: 0, stitchAct: 0, lastPlan: 0, lastAct: 0 });

      assert(totals.cutPlan === expectedTotals.cutPlan, 'Total Cutting Plan should sum sample data');
      assert(totals.cutAct === expectedTotals.cutAct, 'Total Cutting Actual should sum sample data');
      assert(totals.stitchPlan === expectedTotals.stitchPlan, 'Total Stitching Plan should sum sample data');
      assert(totals.stitchAct === expectedTotals.stitchAct, 'Total Stitching Actual should sum sample data');
      assert(totals.lastPlan === expectedTotals.lastPlan, 'Total Lasting Plan should sum sample data');
      assert(totals.lastAct === expectedTotals.lastAct, 'Total Lasting Actual should sum sample data');

      if (logs.length === 0) {
        console.log('All tests passed');
      }
    }

    /**
     * Export the table (excluding the Actions column) to an XLSX file.
     */
    function exportTable() {
      if (typeof XLSX === 'undefined') {
        alert('XLSX library not loaded');
        return;
      }

      const tableClone = document.getElementById('plannerTable').cloneNode(true);

      // Remove the Actions column
      tableClone.querySelectorAll('th:last-child, td:last-child').forEach(el => el.remove());

      // Replace inputs with their current values
      tableClone.querySelectorAll('input').forEach(input => {
        const cell = input.parentElement;
        cell.textContent = input.value;
      });

      const wb = XLSX.utils.table_to_book(tableClone, {sheet: 'Weekly Production Plan'});
      XLSX.writeFile(wb, 'weekly_production_plan.xlsx');
    }

    // Attach event listeners to toolbar buttons
    addRowBtn.addEventListener('click', function() {
      addRow();
      recalcAll();
    });
    add10RowsBtn.addEventListener('click', function() {
      for (let i = 0; i < 10; i++) {
        addRow();
      }
      recalcAll();
    });
    sampleDataBtn.addEventListener('click', function() {
      addSampleData();
    });
    runTestsBtn.addEventListener('click', function() {
      runTests();
    });
    exportBtn.addEventListener('click', function() {
      exportTable();
    });
  });
  </script>
</body>
</html>
